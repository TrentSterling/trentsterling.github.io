<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (GA4) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-27SVZGYHZ3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-27SVZGYHZ3');
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>calm — tront.xyz</title>
<meta name="description" content="A quiet place to breathe. Meditative raymarched shader landscape.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://tront.xyz/calm/">
<meta property="og:title" content="calm — tront.xyz">
<meta property="og:description" content="A quiet place to breathe.">
<meta name="twitter:card" content="summary">
<link rel="icon" href="/favicon.png" type="image/png">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f}
canvas{display:block;width:100%;height:100%;position:fixed;top:0;left:0}

#overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}

#title{
  position:absolute;bottom:2.5rem;left:50%;transform:translateX(-50%);
  font-family:'Courier New',monospace;font-size:0.9rem;letter-spacing:0.4em;
  color:rgba(220,215,200,0.3);text-transform:uppercase;
  transition:opacity 1.5s ease;pointer-events:none;user-select:none;
  text-shadow:0 0 12px rgba(0,0,0,0.5);
}

#audio-hint{
  position:absolute;bottom:50%;left:50%;transform:translate(-50%,50%);
  font-family:'Courier New',monospace;font-size:0.85rem;letter-spacing:0.2em;
  color:rgba(180,170,160,0.0);text-transform:uppercase;
  transition:opacity 3s ease;pointer-events:none;user-select:none;
}
#audio-hint.visible{color:rgba(180,170,160,0.2)}
#audio-hint.fade{color:rgba(180,170,160,0.0)}

#controls{
  position:absolute;bottom:1.5rem;right:1.5rem;
  display:flex;flex-direction:column;gap:0.6rem;align-items:flex-end;
  opacity:0;transition:opacity 0.8s ease;pointer-events:auto;
}
#overlay:hover #controls,#controls:focus-within{opacity:1}

#controls label{
  font-family:'Courier New',monospace;font-size:0.85rem;
  color:rgba(230,225,215,0.85);letter-spacing:0.1em;
  display:flex;align-items:center;gap:0.6rem;
  text-shadow:0 1px 4px rgba(0,0,0,0.8);
}
#controls input[type=range]{
  width:120px;height:4px;-webkit-appearance:none;appearance:none;
  background:rgba(180,170,160,0.2);border-radius:2px;outline:none;
  cursor:pointer;
}
#controls input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;width:14px;height:14px;border-radius:50%;
  background:rgba(220,215,200,0.6);cursor:pointer;
}
#controls input[type=text]{
  width:110px;height:26px;background:rgba(0,0,0,0.5);
  border:1px solid rgba(255,255,255,0.15);border-radius:4px;
  color:rgba(230,225,215,0.85);font-family:'Courier New',monospace;
  font-size:0.85rem;padding:0 8px;outline:none;
}
#controls button{
  background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.15);
  border-radius:4px;color:rgba(230,225,215,0.85);
  font-family:'Courier New',monospace;font-size:0.85rem;
  padding:4px 14px;cursor:pointer;
}
#controls button:hover{background:rgba(0,0,0,0.65);border-color:rgba(255,255,255,0.25)}

#audio-btn{
  position:absolute;bottom:1.5rem;left:1.5rem;
  background:rgba(0,0,0,0.3);border:1px solid rgba(180,170,160,0.2);
  border-radius:50%;width:44px;height:44px;
  display:flex;align-items:center;justify-content:center;
  cursor:pointer;opacity:0;transition:opacity 0.8s ease;
  pointer-events:auto;
}
#overlay:hover #audio-btn{opacity:1}
#audio-btn svg{width:20px;height:20px;fill:rgba(220,215,200,0.5)}

/* HUD */
#hud{
  position:absolute;top:0;left:0;width:100%;height:100%;
  pointer-events:none;font-family:'Courier New',monospace;
  font-size:0.85rem;color:rgba(230,225,215,0.9);
  letter-spacing:0.06em;line-height:1.8;
  text-shadow:0 1px 4px rgba(0,0,0,0.8),0 0 12px rgba(0,0,0,0.5);
}
.hud-panel{
  background:rgba(0,0,0,0.45);backdrop-filter:blur(8px);
  -webkit-backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,0.08);border-radius:8px;
  padding:0.6rem 0.9rem;
}
#hud-tl{position:absolute;top:1rem;left:1.2rem}
#hud-tr{position:absolute;top:1rem;right:1.2rem;text-align:right}
#hud-bl{position:absolute;bottom:4rem;left:1.2rem}

/* Breathing bar */
#breath-bar{
  width:160px;height:5px;background:rgba(180,170,160,0.1);
  border-radius:3px;margin-top:6px;overflow:hidden;
}
#breath-fill{
  height:100%;width:50%;background:rgba(200,190,180,0.35);
  border-radius:3px;transition:width 0.1s linear;
}

/* Controls help */
#controls-help{
  position:absolute;bottom:50%;left:50%;transform:translate(-50%,50%);
  text-align:center;font-family:'Courier New',monospace;
  font-size:0.95rem;color:rgba(220,215,200,0.0);
  letter-spacing:0.12em;line-height:2.2;
  transition:color 2s ease,background 2s ease,border-color 2s ease;
  pointer-events:none;padding:1.2rem 2rem;border-radius:10px;
  background:rgba(0,0,0,0);border:1px solid rgba(255,255,255,0);
  text-shadow:0 1px 4px rgba(0,0,0,0.8);
}
#controls-help.visible{
  color:rgba(230,225,215,0.9);
  background:rgba(0,0,0,0.5);
  border-color:rgba(255,255,255,0.1);
}
#controls-help.fade{
  color:rgba(220,215,200,0.0);
  background:rgba(0,0,0,0);
  border-color:rgba(255,255,255,0);
}

/* Crosshair */
#crosshair{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  width:16px;height:16px;opacity:0;transition:opacity 0.3s;
}
#crosshair.active{opacity:1}
#crosshair::before,#crosshair::after{
  content:'';position:absolute;background:rgba(220,215,200,0.3);
}
#crosshair::before{width:1px;height:100%;left:50%;transform:translateX(-50%)}
#crosshair::after{width:100%;height:1px;top:50%;transform:translateY(-50%)}

/* Ambient clock */
#ambient-clock{
  position:absolute;top:50%;right:2.5rem;transform:translateY(-50%);
  font-family:'Courier New',monospace;font-size:2.8rem;
  color:rgba(180,170,160,0.0);letter-spacing:0.2em;
  transition:color 8s ease;pointer-events:none;user-select:none;
  text-shadow:0 0 30px rgba(180,170,160,0.15);font-weight:100;
}
#ambient-clock.visible{color:rgba(180,170,160,0.15)}

/* Quote */
#quote{
  position:absolute;bottom:6rem;left:50%;transform:translateX(-50%);
  font-family:'Courier New',monospace;font-size:0.95rem;
  color:rgba(180,170,160,0.0);letter-spacing:0.12em;
  text-align:center;max-width:600px;line-height:1.9;
  transition:color 4s ease;pointer-events:none;user-select:none;
  text-shadow:0 2px 6px rgba(0,0,0,0.6);font-style:italic;
}
#quote.visible{color:rgba(220,215,200,0.4)}

/* Pomodoro */
#pomodoro{
  position:absolute;bottom:4rem;right:1.5rem;text-align:right;
  pointer-events:auto;
}
#pomo-display{
  font-family:'Courier New',monospace;font-size:1.6rem;
  color:rgba(230,225,215,0.8);letter-spacing:0.12em;
  text-shadow:0 1px 4px rgba(0,0,0,0.8);
}
#pomo-label{
  font-family:'Courier New',monospace;font-size:0.75rem;
  color:rgba(200,195,185,0.5);letter-spacing:0.18em;
  text-transform:uppercase;margin-bottom:3px;
}
#pomo-bar{
  width:140px;height:4px;background:rgba(180,170,160,0.1);
  border-radius:2px;margin-top:6px;overflow:hidden;
}
#pomo-fill{
  height:100%;width:0%;border-radius:2px;
  transition:width 1s linear,background 0.5s;
}
#pomo-btn{
  background:rgba(0,0,0,0.4);border:1px solid rgba(180,170,160,0.2);
  border-radius:4px;color:rgba(230,225,215,0.6);
  font-family:'Courier New',monospace;font-size:0.8rem;
  padding:4px 14px;cursor:pointer;margin-top:6px;
  letter-spacing:0.12em;
}
#pomo-btn:hover{border-color:rgba(180,170,160,0.4);color:rgba(230,225,215,0.8)}

/* Altitude graph */
#alt-graph{
  position:absolute;bottom:4rem;left:50%;transform:translateX(-50%);
  pointer-events:none;
}
#alt-graph canvas{
  width:200px;height:50px;
  border:1px solid rgba(255,255,255,0.08);border-radius:4px;
  background:rgba(0,0,0,0.35);backdrop-filter:blur(4px);
}
#alt-label{
  font-family:'Courier New',monospace;font-size:0.65rem;
  color:rgba(200,195,185,0.5);text-align:center;letter-spacing:0.1em;
  margin-top:2px;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">
  <div id="hud">
    <div id="hud-tl" class="hud-panel">
      <div id="hud-fps">-- fps</div>
      <div id="hud-res">----</div>
      <div id="hud-seed">seed: --</div>
      <div id="hud-dpr">dpr: --</div>
    </div>
    <div id="hud-tr" class="hud-panel">
      <div id="hud-pos">pos: 0, 0, 0</div>
      <div id="hud-yaw">yaw: 0 pitch: 0</div>
      <div id="hud-time">time: 0.0s</div>
      <div id="hud-mode">mode: drift</div>
      <div id="hud-speed">speed: 1.0x</div>
    </div>
    <div id="hud-bl" class="hud-panel">
      <div>breath</div>
      <div id="breath-bar"><div id="breath-fill"></div></div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="title">calm</div>
  <div id="controls-help">
    wasd — move &nbsp; space/shift — up/down<br>
    mouse — look &nbsp; scroll — speed<br>
    click — lock cursor &nbsp; esc — unlock
  </div>
  <button id="audio-btn" title="Toggle audio">
    <svg id="audio-icon-on" viewBox="0 0 24 24" style="display:none"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    <svg id="audio-icon-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
  </button>
  <div id="ambient-clock"></div>
  <div id="quote"></div>
  <div id="pomodoro" class="hud-panel">
    <div id="pomo-label">focus</div>
    <div id="pomo-display">25:00</div>
    <div id="pomo-bar"><div id="pomo-fill"></div></div>
    <button id="pomo-btn">start</button>
  </div>
  <div id="alt-graph">
    <canvas id="alt-canvas" width="200" height="50"></canvas>
    <div id="alt-label">altitude</div>
  </div>
  <div id="controls">
    <label>seed <input type="text" id="seed-input" placeholder="random"></label>
    <label>speed <input type="range" id="speed" min="0" max="100" value="30"></label>
    <label>volume <input type="range" id="volume" min="0" max="100" value="50"></label>
    <button id="fs-btn">fullscreen</button>
  </div>
</div>

<!-- ======== VERTEX SHADER ======== -->
<script id="vs" type="x-shader/x-vertex">
attribute vec2 a_pos;
void main(){gl_Position=vec4(a_pos,0.0,1.0);}
</script>

<!-- ======== FRAGMENT SHADER ======== -->
<script id="fs" type="x-shader/x-fragment">
precision highp float;
uniform vec2 u_res;
uniform float u_time;
uniform float u_speed;
uniform vec3 u_camPos;
uniform vec3 u_camFwd;
uniform vec3 u_camRight;
uniform vec3 u_camUp;
uniform float u_breath;
uniform float u_seed;
uniform float u_transition;
uniform float u_prevSeed;
uniform float u_mobile;
uniform float u_velocity; // camera speed magnitude for speed lines

// --- Hash functions ---
float hash21(vec2 p){
    p=fract(p*vec2(443.897,397.297));
    p+=dot(p,p+19.19);
    return fract(p.x*p.y);
}
float hash31(vec3 p){
    p=fract(p*vec3(443.897,397.297,491.187));
    p+=dot(p,p.yzx+19.19);
    return fract((p.x+p.y)*p.z);
}

// --- Value noise ---
float vnoise(vec3 p){
    vec3 i=floor(p);
    vec3 f=fract(p);
    f=f*f*(3.0-2.0*f);
    float a=hash31(i);
    float b=hash31(i+vec3(1,0,0));
    float c=hash31(i+vec3(0,1,0));
    float d=hash31(i+vec3(1,1,0));
    float e=hash31(i+vec3(0,0,1));
    float g=hash31(i+vec3(1,0,1));
    float h=hash31(i+vec3(0,1,1));
    float k=hash31(i+vec3(1,1,1));
    return mix(mix(mix(a,b,f.x),mix(c,d,f.x),f.y),
               mix(mix(e,g,f.x),mix(h,k,f.x),f.y),f.z);
}

// --- FBM ---
float fbm(vec3 p, float oct){
    float v=0.0, a=0.5;
    for(float i=0.0;i<6.0;i+=1.0){
        if(i>=oct) break;
        v+=a*vnoise(p);
        p=p*2.03+vec3(1.7,1.2,2.8);
        a*=0.5;
    }
    return v;
}

// --- IQ Cosine palette (boosted saturation) ---
vec3 pal(float t, float sd){
    float s=sd*6.283;
    vec3 a=vec3(0.55,0.5,0.55);
    vec3 b=vec3(0.45,0.4,0.45);
    vec3 c=vec3(0.8+sin(s)*0.3, 1.0, 0.9+cos(s)*0.2);
    vec3 d=vec3(0.1+sin(s*2.0)*0.15, 0.25, 0.35+cos(s*1.3)*0.2);
    return a+b*cos(6.2832*(c*t+d));
}
// Shifted palette for variety
vec3 pal2(float t, float sd){
    return pal(t+0.33,sd+0.17);
}
vec3 pal3(float t, float sd){
    return pal(t+0.67,sd+0.41);
}

// --- SDF ---
float sdSphere(vec3 p,float r){return length(p)-r;}
float sdRBox(vec3 p,vec3 b,float r){
    vec3 q=abs(p)-b;
    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0)-r;
}
float sdCylinder(vec3 p,float r,float h){
    vec2 d=abs(vec2(length(p.xz),p.y))-vec2(r,h);
    return min(max(d.x,d.y),0.0)+length(max(d,0.0));
}
float sdTorus(vec3 p,float R,float r){
    vec2 q=vec2(length(p.xz)-R,p.y);
    return length(q)-r;
}
float smin(float a,float b,float k){
    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);
    return mix(b,a,h)-k*h*(1.0-h);
}

// --- Terrain height at xz ---
float terrainH(vec2 xz, float sd, float oct){
    float t=u_time*u_speed;
    vec3 tp=vec3(xz*0.12,0.0)+vec3(sd*13.7,sd*7.3,0.0);
    tp.xy+=t*0.02;
    float h=fbm(tp, oct)*3.0;
    h+=sin(xz.x*0.06+t*0.08)*cos(xz.y*0.05+t*0.06)*1.0;
    return h;
}

// --- Scene distance with material ID ---
// Returns vec2(distance, materialID)
// mat 0=ground, 1=sphere, 2=cube, 3=structure, 4=crystal, 5=cairn
vec2 mapMat(vec3 p, float sd, float oct){
    float t=u_time*u_speed;
    float breath=u_breath;
    float mat=0.0;

    // Ground
    float h=terrainH(p.xz, sd, oct);
    float ground=p.y-h;
    float d=ground;

    // Breathing spheres
    float spheres=1e5;
    float cellSp=40.0;
    vec3 spCell=floor(p/cellSp);
    vec3 spLocal=p-spCell*cellSp-cellSp*0.5;
    float spHash=hash31(spCell+sd*31.0);
    if(spHash<0.4){
        float sx=(spHash*2.0-1.0)*10.0+sin(t*0.04+spHash*6.0)*3.0;
        float sz=(fract(spHash*7.7)*2.0-1.0)*10.0+cos(t*0.03+spHash*4.0)*3.0;
        float r=1.0+spHash*0.8+breath*0.3;
        float sy=terrainH(spCell.xz*cellSp+vec2(sx,sz),sd,2.0)+r+1.0+breath*0.6;
        vec3 sCenter=vec3(sx,sy-spCell.y*cellSp-cellSp*0.5,sz);
        spheres=sdSphere(spLocal-sCenter,r);
    }
    if(spheres<d){ mat=1.0; }
    d=smin(d,spheres,3.0);

    // Voxel cubes
    float cubes=1e5;
    float cs=5.0;
    vec3 cid=floor(p/cs);
    vec3 cp2=mod(p,cs)-cs*0.5;
    float ch=hash31(cid+sd*47.0);
    if(ch<0.2 && cid.y<1.0){
        float fade=sin(t*0.06+ch*6.28)*0.5+0.5;
        fade=smoothstep(0.1,0.9,fade);
        float sz=0.3+ch*0.4;
        sz*=fade;
        sz+=breath*0.05;
        float rot=ch*6.28+t*0.02;
        float cr=cos(rot),sr=sin(rot);
        vec2 rp=mat2(cr,sr,-sr,cr)*cp2.xz;
        vec3 rcp=vec3(rp.x,cp2.y-sz-terrainH(cid.xz*cs,sd,2.0),rp.y);
        cubes=sdRBox(rcp,vec3(sz),0.1);
    }
    if(cubes<d){ mat=2.0; }
    d=smin(d,cubes,0.8);

    // Crystal clusters — medium grid, tall sharp shapes
    float crystals=1e5;
    float crCell=30.0;
    vec3 crId=floor(p/crCell);
    vec3 crLocal=p-crId*crCell-crCell*0.5;
    float crh=hash31(crId+sd*59.0);
    if(crh<0.15){
        float cx=(crh*2.0-1.0)*8.0;
        float cz=(fract(crh*11.0)*2.0-1.0)*8.0;
        float gH=hash21(crId.xz+sd*3.0)*3.0;
        vec3 cBase=vec3(cx,gH-crId.y*crCell-crCell*0.5,cz);
        // 3 crystals in a cluster
        for(float ci=0.0;ci<3.0;ci+=1.0){
            float ca=ci*2.09+crh*6.28;
            float coff=1.0+fract(crh*17.0+ci*3.3)*1.5;
            vec3 cpos=cBase+vec3(cos(ca)*coff,0.0,sin(ca)*coff);
            float cH=2.5+fract(crh*7.0+ci*2.1)*4.0+breath*0.3;
            float cR=0.3+fract(crh*3.0+ci)*0.4;
            // Tapered cylinder (crystal shape)
            vec3 lp=crLocal-cpos;
            lp.y-=cH;
            float taper=1.0-clamp(lp.y/(cH*2.0)+0.5,0.0,1.0)*0.7;
            float crDist=sdCylinder(lp,cR*taper,cH)-0.05;
            // Point on top
            crDist=smin(crDist,sdSphere(crLocal-cpos-vec3(0.0,cH*2.0+0.3,0.0),cR*0.5),0.3);
            crystals=min(crystals,crDist);
        }
    }
    if(crystals<d){ mat=4.0; }
    d=smin(d,crystals,0.5);

    // Cairns — stacked rounded stones
    float cairns=1e5;
    float cairnCell=55.0;
    vec3 cairnId=floor(p/cairnCell);
    vec3 cairnLocal=p-cairnId*cairnCell-cairnCell*0.5;
    float cairnH=hash31(cairnId+sd*83.0);
    if(cairnH<0.12){
        float bx=(cairnH*2.0-1.0)*15.0;
        float bz=(fract(cairnH*9.0)*2.0-1.0)*15.0;
        float gH2=hash21(cairnId.xz+sd*5.0)*3.0;
        vec3 cBase2=vec3(bx,gH2-cairnId.y*cairnCell-cairnCell*0.5,bz);
        float stackY=0.0;
        // 3-5 stacked stones
        float numStones=3.0+floor(fract(cairnH*23.0)*3.0);
        for(float si=0.0;si<5.0;si+=1.0){
            if(si>=numStones) break;
            float sr2=1.2-si*0.2+breath*0.05;
            float wobble=sin(t*0.015+si*1.5+cairnH*5.0)*0.15;
            vec3 stonePos=cBase2+vec3(wobble,stackY+sr2,wobble*0.5);
            cairns=smin(cairns,sdSphere(cairnLocal-stonePos,sr2),0.4);
            stackY+=sr2*1.6;
        }
    }
    if(cairns<d){ mat=5.0; }
    d=smin(d,cairns,0.8);

    // Large structures — monoliths, arches, rings
    float structs=1e5;
    float bigCell=120.0;
    vec3 bCell=floor(p/bigCell);
    vec3 bLocal=p-bCell*bigCell-bigCell*0.5;
    float bh=hash31(bCell+sd*73.0);
    float bh2=fract(bh*13.37);
    if(bh<0.25){
        float bx=(bh*2.0-1.0)*30.0;
        float bz=(bh2*2.0-1.0)*30.0;
        float groundH2=hash21(bCell.xz+sd*7.0)*3.0;
        vec3 base=vec3(bx,groundH2-bCell.y*bigCell-bigCell*0.5,bz);
        float kind=fract(bh*99.0);
        if(kind<0.35){
            float pillarH=6.0+bh2*8.0+breath*0.5;
            float pillarR=1.2+bh*1.5;
            vec3 pp=bLocal-base-vec3(0.0,pillarH,0.0);
            structs=sdCylinder(pp,pillarR,pillarH)-0.3;
            structs=smin(structs,sdSphere(bLocal-base-vec3(0.0,pillarH*2.0+0.5,0.0),pillarR*1.3+breath*0.3),1.5);
        } else if(kind<0.65){
            float archH=5.0+bh2*6.0;
            float archW=3.0+bh*3.0;
            float archR=0.8+bh2*0.5;
            vec3 lp=bLocal-base;
            float left=sdCylinder(lp-vec3(-archW,archH,0.0),archR,archH)-0.2;
            float right=sdCylinder(lp-vec3(archW,archH,0.0),archR,archH)-0.2;
            vec3 tp2=lp-vec3(0.0,archH*2.0,0.0);
            float archTop=sdTorus(tp2,archW,archR*1.2);
            archTop=max(archTop,-tp2.y);
            structs=min(left,right);
            structs=smin(structs,archTop,1.0);
        } else {
            float ringH=4.0+bh2*5.0+sin(t*0.02+bh*8.0)*1.5;
            float ringR=3.0+bh*4.0;
            float ringr=0.4+bh2*0.4+breath*0.15;
            vec3 rp2=bLocal-base-vec3(0.0,ringH,0.0);
            float tiltA=0.3+sin(t*0.008+bh2*5.0)*0.2;
            float tc=cos(tiltA),ts=sin(tiltA);
            vec3 rp3=vec3(rp2.x,rp2.y*tc-rp2.z*ts,rp2.y*ts+rp2.z*tc);
            structs=sdTorus(rp3,ringR,ringr);
        }
    }
    if(structs<d){ mat=3.0; }
    d=smin(d,structs,1.5);

    return vec2(d, mat);
}

// Distance-only version for normals/AO (cheaper)
float mapDist(vec3 p, float sd, float oct){
    return mapMat(p,sd,oct).x;
}

vec3 calcN(vec3 p, float sd, float oct){
    vec2 e=vec2(0.025,0.0);
    return normalize(vec3(
        mapDist(p+e.xyy,sd,oct)-mapDist(p-e.xyy,sd,oct),
        mapDist(p+e.yxy,sd,oct)-mapDist(p-e.yxy,sd,oct),
        mapDist(p+e.yyx,sd,oct)-mapDist(p-e.yyx,sd,oct)
    ));
}

float ao(vec3 p, vec3 n, float sd, float oct){
    float o=0.0,s=1.0;
    for(float i=0.0;i<4.0;i+=1.0){
        float h=0.03+0.15*i;
        float dd=mapDist(p+n*h,sd,oct);
        o+=(h-dd)*s;
        s*=0.65;
    }
    return clamp(1.0-2.0*o,0.0,1.0);
}

// --- Sky color with distinct atmosphere layers ---
vec3 skyColor(vec3 rd, float sd, float time){
    float camH=u_camPos.y;

    // Layer weights — smooth transitions between 6 altitude bands
    float wGround   = 1.0-smoothstep(0.0,20.0,camH);     // 0-20: ground haze
    float wLowCloud = smoothstep(8.0,18.0,camH)*(1.0-smoothstep(18.0,35.0,camH)); // 8-35: cloud layer
    float wHighSky  = smoothstep(20.0,45.0,camH)*(1.0-smoothstep(45.0,70.0,camH)); // 20-70: clear blue
    float wStrato   = smoothstep(50.0,75.0,camH)*(1.0-smoothstep(75.0,105.0,camH)); // 50-105: stratosphere violet
    float wMeso     = smoothstep(85.0,110.0,camH)*(1.0-smoothstep(110.0,135.0,camH)); // 85-135: mesosphere dark
    float wSpace    = smoothstep(115.0,145.0,camH); // 115+: space

    // Each layer has its own sky gradient
    // Ground: warm haze, amber horizon
    vec3 skyGround;
    {
        vec3 hi=pal(0.65,sd)*0.55+vec3(0.04,0.05,0.12);
        vec3 lo=pal2(0.2,sd)*0.65+vec3(0.14,0.08,0.04);
        skyGround=mix(lo,hi,clamp(rd.y*0.5+0.5,0.0,1.0));
        skyGround+=pal3(0.3,sd)*0.3*exp(-6.0*rd.y*rd.y); // warm horizon band
    }

    // Cloud layer: brighter, whiter, hazier
    vec3 skyCloud;
    {
        vec3 hi=vec3(0.45,0.5,0.6)+pal(0.5,sd)*0.2;
        vec3 lo=vec3(0.55,0.52,0.5)+pal2(0.3,sd)*0.15;
        skyCloud=mix(lo,hi,clamp(rd.y*0.6+0.4,0.0,1.0));
        // Volumetric haze feel — whiter, less saturated
        float haze=exp(-3.0*abs(rd.y));
        skyCloud=mix(skyCloud,vec3(0.6,0.58,0.55),haze*0.5);
    }

    // High sky: clear deep blue, sharper contrast
    vec3 skyHigh;
    {
        vec3 hi=pal(0.7,sd)*0.5+vec3(0.02,0.04,0.2);
        vec3 lo=pal2(0.45,sd)*0.4+vec3(0.08,0.06,0.08);
        skyHigh=mix(lo,hi,clamp(rd.y*0.5+0.5,0.0,1.0));
    }

    // Stratosphere: violet/purple tones, thin air
    vec3 skyStrato;
    {
        vec3 hi=vec3(0.08,0.04,0.2)+pal(0.8,sd)*0.15;
        vec3 lo=vec3(0.15,0.08,0.18)+pal3(0.6,sd)*0.12;
        skyStrato=mix(lo,hi,clamp(rd.y*0.5+0.5,0.0,1.0));
        // Faint glow at horizon — last traces of atmosphere
        skyStrato+=vec3(0.12,0.08,0.2)*exp(-4.0*rd.y*rd.y);
    }

    // Mesosphere: near-black with hints of deep blue
    vec3 skyMeso;
    {
        skyMeso=vec3(0.015,0.012,0.04)+pal(0.75,sd)*0.03;
        // Aurora-like shimmer at horizon
        float aur=exp(-6.0*rd.y*rd.y)*vnoise(vec3(rd.xz*8.0,time*0.02+sd));
        vec3 aurCol=pal2(aur+time*0.005,sd)*0.08;
        skyMeso+=aurCol*smoothstep(0.2,0.5,aur);
    }

    // Space: black with nebula
    vec3 skySpace;
    {
        skySpace=vec3(0.004,0.003,0.012);
        float nebula=vnoise(vec3(rd.xy*3.0+sd*5.0,rd.z*3.0))*0.5+
                     vnoise(vec3(rd.xz*6.0+sd*11.0,rd.y*6.0))*0.3;
        nebula=smoothstep(0.3,0.7,nebula);
        vec3 nebulaCol=pal2(nebula*0.6+0.2,sd)*0.08;
        skySpace+=nebulaCol*wSpace;
    }

    // Blend all layers by weight
    vec3 sky=skyGround*wGround
            +skyCloud*wLowCloud
            +skyHigh*wHighSky
            +skyStrato*wStrato
            +skyMeso*wMeso
            +skySpace*wSpace;
    // Normalize when between bands (weights don't always sum to 1)
    float wSum=wGround+wLowCloud+wHighSky+wStrato+wMeso+wSpace;
    if(wSum>0.01) sky/=wSum;

    // Atmosphere rim — looking sideways/down from high altitude
    if(camH>40.0){
        float rimStrength=smoothstep(40.0,100.0,camH);
        float horizonGlow=exp(-6.0*rd.y*rd.y)*rimStrength;
        // Multi-color rim: blue-white core + orange fringe
        vec3 rimCore=vec3(0.35,0.5,0.85)+pal2(0.3,sd)*0.3;
        vec3 rimFringe=vec3(0.25,0.15,0.05)+pal(0.15,sd)*0.2;
        float rimBand=exp(-20.0*(rd.y-0.05)*(rd.y-0.05));
        sky+=rimCore*horizonGlow*0.5;
        sky+=rimFringe*rimBand*rimStrength*0.3;

        // Planet glow when looking down from high up
        float downGlow=max(-rd.y,0.0)*smoothstep(70.0,140.0,camH);
        vec3 planetGlow=pal(0.2,sd)*0.25+vec3(0.04,0.06,0.03);
        sky=mix(sky,planetGlow,downGlow*0.5);
    }

    // Sun disc + halo
    vec3 sunDir=normalize(vec3(sin(time*0.02)*0.4,0.3,cos(time*0.02)*0.4));
    float sun=pow(max(dot(rd,sunDir),0.0),80.0);
    float sunGlow=pow(max(dot(rd,sunDir),0.0),8.0);
    float sunBright=mix(2.5,6.0,wSpace);
    sky+=pal(0.15,sd)*sun*sunBright;
    sky+=pal2(0.1,sd)*sunGlow*mix(0.15,0.03,wSpace);

    // Stars — progressively visible from stratosphere up
    float starVis0=wStrato+wMeso+wSpace; // stars start in stratosphere
    float star=hash31(floor(rd*300.0));
    float starThresh=mix(0.999,0.99,starVis0);
    float starOn=step(starThresh,star);
    float starMask=mix(smoothstep(0.0,0.3,rd.y),1.0,smoothstep(0.3,1.0,starVis0));
    float starBright=mix(0.3,1.5,starVis0);
    float twinkle=sin(time*0.5+star*100.0)*0.3+0.7;
    sky+=starOn*starMask*starBright*twinkle;

    // Dense star field in deep space + mesosphere
    if(starVis0>0.15){
        float star2=hash31(floor(rd*800.0)+vec3(77.0));
        float starVis2=step(0.993,star2)*starVis0;
        float twinkle2=sin(time*0.3+star2*50.0)*0.2+0.8;
        sky+=starVis2*0.35*twinkle2*vec3(0.8,0.85,1.0);
        // Third layer: very faint tiny stars
        float star3=hash31(floor(rd*1500.0)+vec3(133.0));
        float starVis3=step(0.996,star3)*wSpace;
        sky+=starVis3*0.15*vec3(0.9,0.9,1.0);
    }

    return sky;
}

// --- Single cloud plane renderer ---
vec3 renderCloudPlane(vec3 ro, vec3 rd, float sd, vec3 sky, float time, float cloudH, float scale, float opacity, vec3 tint, float fadeAbove){
    if(abs(rd.y)<0.001) return sky;
    float tCloud=(cloudH-ro.y)/rd.y;
    if(tCloud<0.0||tCloud>400.0) return sky;
    float cloudAlpha=1.0-smoothstep(fadeAbove,fadeAbove+80.0,ro.y);
    if(cloudAlpha<0.01) return sky;

    vec3 cp=ro+rd*tCloud;
    vec2 uv2=cp.xz*scale+time*0.005;
    float n1=vnoise(vec3(uv2*3.0,time*0.01+sd*10.0));
    float n2=vnoise(vec3(uv2*6.0+5.0,time*0.015+sd*5.0));
    float n3=vnoise(vec3(uv2*12.0+10.0,time*0.008));
    float density=n1*0.5+n2*0.3+n3*0.2;
    density=smoothstep(0.32,0.68,density);
    density*=exp(-0.003*tCloud); // fade at distance
    float clight=n1*0.3+0.7;
    vec3 cloudCol=tint*clight;

    return mix(sky,cloudCol,density*opacity*cloudAlpha);
}

// --- Multi-layer clouds ---
vec3 renderClouds(vec3 ro, vec3 rd, float sd, vec3 sky, float time){
    vec3 col=sky;
    // Layer 1: Low cumulus clouds at y=15 (warm, thick)
    vec3 tint1=pal(0.3,sd)*0.75+vec3(0.22,0.19,0.16);
    col=renderCloudPlane(ro,rd,sd,col,time, 15.0, 0.008, 0.65, tint1, 60.0);

    // Layer 2: Mid-altitude wisps at y=35 (cooler, thinner)
    vec3 tint2=pal2(0.5,sd)*0.5+vec3(0.3,0.3,0.35);
    col=renderCloudPlane(ro,rd,sd,col,time*1.3, 35.0, 0.005, 0.4, tint2, 90.0);

    // Layer 3: High cirrus at y=60 (icy, very thin, wide)
    vec3 tint3=vec3(0.35,0.38,0.5)+pal3(0.65,sd)*0.15;
    col=renderCloudPlane(ro,rd,sd,col,time*0.7, 60.0, 0.003, 0.25, tint3, 120.0);

    return col;
}

// --- Water plane at y=waterH ---
vec3 renderWater(vec3 ro, vec3 rd, float sd, float oct, float time, vec3 behindCol){
    float waterH=-0.5;
    // Only if ray hits water plane
    if(rd.y>-0.001) return behindCol;
    float tWater=(waterH-ro.y)/rd.y;
    if(tWater<0.0||tWater>100.0) return behindCol;

    vec3 wp=ro+rd*tWater;

    // Animated water normal from noise
    vec2 wuv=wp.xz;
    float t2=time;
    float wx=vnoise(vec3(wuv*0.3+t2*0.03,t2*0.02+sd))*2.0-1.0;
    float wz=vnoise(vec3(wuv*0.3+100.0+t2*0.025,t2*0.018+sd))*2.0-1.0;
    vec3 wn=normalize(vec3(wx*0.08,1.0,wz*0.08));

    // Reflect ray
    vec3 rrd=reflect(rd,wn);
    rrd.y=max(rrd.y,0.01);
    vec3 reflCol=skyColor(rrd,sd,time);
    // Add cloud reflection
    reflCol=renderClouds(wp,rrd,sd,reflCol,time);

    // Fresnel
    float fres=pow(1.0-max(dot(wn,-rd),0.0),4.0);
    fres=0.3+0.7*fres;

    // Water tint — more colorful
    vec3 waterTint=pal3(0.5,sd)*0.25+vec3(0.03,0.06,0.1);

    vec3 col=mix(waterTint,reflCol,fres);

    // Distance fog on water — blend to sky at horizon
    float wfog=1.0-exp(-0.00015*tWater*tWater);
    col=mix(col,behindCol,wfog);

    return col;
}

vec3 render(vec3 ro, vec3 rd, float sd, float oct, float maxSteps){
    float time=u_time*u_speed;

    // Sky + clouds
    vec3 sky=skyColor(rd,sd,time);
    sky=renderClouds(ro,rd,sd,sky,time);

    // Time-varying fog — shifts hue over time for variety
    float fogCycle=sin(time*0.008)*0.5+0.5; // slow 0-1 cycle
    vec3 fogWarm=pal(0.15+fogCycle*0.2,sd)*0.9+vec3(0.1,0.05,0.02);
    vec3 fogCool=pal2(0.6+fogCycle*0.15,sd)*0.6+vec3(0.02,0.04,0.1);
    vec3 fogCol=mix(fogWarm,fogCool,clamp(rd.y*0.5+0.5,0.0,1.0));
    // Blend in a third color at the horizon band
    vec3 fogMid=pal3(0.3+fogCycle*0.3,sd)*0.5+vec3(0.06,0.04,0.06);
    fogCol=mix(fogCol,fogMid,exp(-8.0*rd.y*rd.y));
    vec3 horizonCol=mix(fogCol,sky,0.45);

    // Raymarch
    float maxDist=120.0;
    float t=0.0;
    float matID=0.0;
    for(float i=0.0;i<100.0;i++){
        if(i>=maxSteps) break;
        vec3 p=ro+rd*t;
        vec2 dm=mapMat(p,sd,oct);
        if(dm.x<0.01*t){ matID=dm.y; break; }
        t+=dm.x*0.9;
        if(t>maxDist) break;
    }

    if(t>maxDist){
        vec3 miss=renderWater(ro,rd,sd,oct,time,sky);
        return miss;
    }

    vec3 p=ro+rd*t;
    vec3 n=calcN(p,sd,oct);

    // Two-tone lighting: main light + colored fill
    float sunAngle=time*0.025;
    vec3 ld=normalize(vec3(sin(sunAngle)*0.5,0.7,cos(sunAngle)*0.5));
    vec3 ld2=normalize(vec3(-cos(sunAngle)*0.3,0.2,sin(sunAngle)*0.3)); // fill from opposite side
    float diff=dot(n,ld)*0.5+0.5;
    diff*=diff;
    float diff2=dot(n,ld2)*0.5+0.5;
    float occ=ao(p,n,sd,oct);
    float fres=pow(1.0-max(dot(n,-rd),0.0),3.0);

    // Light colors shift over time
    vec3 sunCol=pal(0.15+fogCycle*0.15,sd)*1.3+vec3(0.2,0.15,0.1);
    vec3 fillCol=pal3(0.5+fogCycle*0.2,sd)*0.4+vec3(0.05,0.08,0.12);

    // Material color based on ID — more variation with position and time
    float nv=vnoise(p*0.15+sd*10.0);
    float nv2=vnoise(p*0.07+vec3(time*0.01)); // slow position-based color shift
    vec3 matCol;
    if(matID<0.5){
        // Ground — earthy with color pools
        matCol=pal(nv*0.5+0.15+nv2*0.15,sd)*1.2+vec3(0.05,0.03,0.0);
        // Color patches on ground
        matCol=mix(matCol,pal2(nv*0.4+0.3,sd)*1.0,smoothstep(0.4,0.6,nv2)*0.4);
    } else if(matID<1.5){
        // Breathing spheres — warm saturated, each slightly different
        float sphereHue=hash31(floor(p/40.0)+sd*31.0);
        matCol=pal2(nv*0.3+sphereHue*0.4+0.1,sd)*1.5+vec3(0.15,0.05,0.02);
    } else if(matID<2.5){
        // Cubes — cool tones, each cube unique
        float cubeHue=hash31(floor(p/5.0)+sd*47.0);
        matCol=pal3(cubeHue*0.6+nv*0.2+0.3,sd)*1.4+vec3(0.02,0.08,0.1);
    } else if(matID<3.5){
        // Large structures — warm stone with colored veins
        matCol=pal(nv*0.2+0.4,sd)*1.0+vec3(0.12,0.1,0.1);
        vec3 vein=pal2(nv*0.8+0.5,sd)*0.6;
        matCol=mix(matCol,vein,smoothstep(0.45,0.55,vnoise(p*0.4))*0.35);
    } else if(matID<4.5){
        // Crystals — vibrant gem-like, each cluster different
        float crystHue=hash31(floor(p/30.0)+sd*59.0);
        matCol=pal2(crystHue*0.5+nv*0.4+0.2,sd)*2.0+vec3(0.1,0.05,0.15);
    } else {
        // Cairns — warm stone, subtle variation
        float cairnHue=hash31(floor(p/55.0)+sd*83.0);
        matCol=pal3(cairnHue*0.3+nv*0.3+0.15,sd)*1.3+vec3(0.1,0.07,0.03);
    }

    // Compose with two-tone lighting
    vec3 col=vec3(0.0);
    col+=matCol*diff*occ*sunCol*1.5;
    col+=matCol*diff2*fillCol*0.5;
    col+=matCol*0.2;

    // Fresnel rim — tinted by opposite light for color contrast
    vec3 rimCol=mix(pal2(0.6,sd),pal3(0.4,sd),fogCycle);
    col+=rimCol*fres*0.7;

    // Specular on crystals
    if(matID>3.5 && matID<4.5){
        float spec=pow(max(dot(reflect(-ld,n),-rd),0.0),32.0);
        col+=pal2(0.5+fogCycle*0.2,sd)*spec*1.8;
    }

    // Specular glint on spheres too
    if(matID>0.5 && matID<1.5){
        float spec=pow(max(dot(reflect(-ld,n),-rd),0.0),16.0);
        col+=sunCol*spec*0.4;
    }

    // Distance fog — color shifts with depth
    float fog=1.0-exp(-0.00015*t*t);
    vec3 depthFog=mix(fogCol,horizonCol,smoothstep(20.0,80.0,t));
    col=mix(col,depthFog,fog);
    col=mix(col,sky,smoothstep(60.0,maxDist,t));

    return col;
}

void main(){
    float oct=u_mobile>0.5?3.0:5.0;
    float maxSteps=u_mobile>0.5?40.0:80.0;

    vec2 uv=(gl_FragCoord.xy-u_res*0.5)/u_res.y;

    // Camera from JS
    vec3 ro=u_camPos;
    vec3 rd=normalize(u_camFwd+uv.x*u_camRight+uv.y*u_camUp);

    vec3 col=render(ro,rd,u_seed,oct,maxSteps);

    if(u_transition>0.01){
        vec3 col2=render(ro,rd,u_prevSeed,oct,maxSteps);
        col=mix(col,col2,u_transition);
    }

    // Tonemap (gentle)
    col=col/(0.7+col);

    // Vignette (soft)
    vec2 vuv=gl_FragCoord.xy/u_res;
    float vig=vuv.x*vuv.y*(1.0-vuv.x)*(1.0-vuv.y);
    col*=mix(0.7,1.0,clamp(pow(vig*16.0,0.35),0.0,1.0));

    // World-space speed streaks — 3D particles that fly past camera
    float spdNorm=clamp(u_velocity/30.0, 0.0, 1.0);
    if(spdNorm>0.03){
        vec2 uv2=(gl_FragCoord.xy-u_res*0.5)/u_res.y;
        vec3 ro2=u_camPos;
        vec3 rd2=normalize(u_camFwd+uv2.x*u_camRight+uv2.y*u_camUp);

        // Two layers of world-space streaks at different scales
        for(float layer=0.0;layer<2.0;layer+=1.0){
            float cellSize=3.0+layer*5.0; // 3 and 8 unit cells
            float invCell=1.0/cellSize;

            // March a short distance along the ray to find nearby streak cells
            for(float step2=0.0;step2<4.0;step2+=1.0){
                float rayT=2.0+step2*4.0+layer*3.0; // sample at 2,6,10,14... and 5,9,13,17...
                vec3 wp=ro2+rd2*rayT;

                // Snap to cell grid
                vec3 cellId=floor(wp*invCell);
                vec3 cellCenter=(cellId+0.5)*cellSize;

                // Random offset within cell + existence check
                float ch=hash31(cellId+layer*77.0+u_seed*3.0);
                if(ch>0.88){ // ~12% of cells have a streak
                    // Particle position in cell
                    vec3 ppos=cellCenter+vec3(
                        (hash31(cellId*1.3+vec3(1.0))-0.5)*cellSize*0.7,
                        (hash31(cellId*2.7+vec3(2.0))-0.5)*cellSize*0.7,
                        (hash31(cellId*3.1+vec3(3.0))-0.5)*cellSize*0.7
                    );

                    // Streak direction: motion-aligned (camera forward)
                    float streakLen=0.3+spdNorm*1.5+layer*0.5;
                    // Closest point on streak line to ray
                    vec3 toP=ppos-ro2;
                    float along=dot(toP,rd2);
                    if(along>1.0){ // in front of camera
                        vec3 closest=ro2+rd2*along;
                        float dist2=length(closest-ppos);
                        // Thinner at distance, thicker close
                        float thickness=0.03+layer*0.02;
                        float bright=smoothstep(thickness,thickness*0.3,dist2/along);
                        // Streak elongation along camera forward
                        float streakPhase=fract(dot(ppos,u_camFwd)*0.5+u_time*spdNorm*2.0);
                        bright*=smoothstep(0.0,0.3,streakPhase)*smoothstep(1.0,0.5,streakPhase);
                        // Fade with distance
                        bright*=exp(-along*0.08);
                        // Color: white-blue, slightly tinted
                        vec3 streakCol=mix(vec3(0.85,0.9,1.0),vec3(1.0,0.95,0.8),ch);
                        col+=streakCol*bright*spdNorm*0.5;
                    }
                }
            }
        }
    }

    // Grain
    col+=hash31(vec3(gl_FragCoord.xy,fract(u_time*71.0)))*0.025-0.0125;

    // Gamma
    col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2));

    gl_FragColor=vec4(col,1.0);
}
</script>

<script>
// ============================================
// MULBERRY32 SEEDED PRNG (same as lofigen)
// ============================================
function mulberry32(seed) {
    if (typeof seed === 'string') {
        let h = 0;
        for (let i = 0; i < seed.length; i++) {
            h = ((h << 5) - h + seed.charCodeAt(i)) | 0;
        }
        seed = h >>> 0;
    }
    seed = seed >>> 0;
    return function() {
        seed |= 0;
        seed = (seed + 0x6D2B79F5) | 0;
        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function seedToFloat(s) {
    if (typeof s === 'number') return s;
    let h = 0;
    for (let i = 0; i < s.length; i++) {
        h = ((h << 5) - h + s.charCodeAt(i)) | 0;
    }
    return (h >>> 0) / 4294967296;
}

// ============================================
// DEBUG LOGGING
// ============================================
const dbg = (ok, msg) => console.log(`%c[${ok?'OK':'FAIL'}] ${msg}`, `color:${ok?'#4f4':'#f44'};font-weight:bold`);

// ============================================
// WEBGL SETUP
// ============================================
const canvas = document.getElementById('c');
dbg(!!canvas, 'Canvas element found');

const gl = canvas.getContext('webgl', { antialias: false, alpha: false });
dbg(!!gl, 'WebGL context created');

function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    const ok = gl.getShaderParameter(s, gl.COMPILE_STATUS);
    const label = type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment';
    dbg(ok, `${label} shader compiled`);
    if (!ok) {
        console.error(gl.getShaderInfoLog(s));
        return null;
    }
    return s;
}

const vs = compileShader(gl.VERTEX_SHADER, document.getElementById('vs').textContent);
const fs = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
const linked = gl.getProgramParameter(prog, gl.LINK_STATUS);
dbg(linked, 'Program linked');
if (!linked) console.error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

// Fullscreen triangle
const aPos = gl.getAttribLocation(prog, 'a_pos');
dbg(aPos >= 0, `a_pos attrib location = ${aPos}`);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uRes = gl.getUniformLocation(prog, 'u_res');
const uTime = gl.getUniformLocation(prog, 'u_time');
const uSpeed = gl.getUniformLocation(prog, 'u_speed');
const uCamPos = gl.getUniformLocation(prog, 'u_camPos');
const uCamFwd = gl.getUniformLocation(prog, 'u_camFwd');
const uCamRight = gl.getUniformLocation(prog, 'u_camRight');
const uCamUp = gl.getUniformLocation(prog, 'u_camUp');
const uBreath = gl.getUniformLocation(prog, 'u_breath');
const uSeed = gl.getUniformLocation(prog, 'u_seed');
const uTransition = gl.getUniformLocation(prog, 'u_transition');
const uPrevSeed = gl.getUniformLocation(prog, 'u_prevSeed');
const uMobile = gl.getUniformLocation(prog, 'u_mobile');
const uVelocity = gl.getUniformLocation(prog, 'u_velocity');

const uniforms = {uRes,uTime,uSpeed,uCamPos,uCamFwd,uCamRight,uCamUp,uBreath,uSeed,uTransition,uPrevSeed,uMobile};
const uniformNames = Object.keys(uniforms);
const allUniformsOk = uniformNames.every(n => uniforms[n] !== null);
dbg(allUniformsOk, `All ${uniformNames.length} uniforms located` + (allUniformsOk ? '' : ' — MISSING: ' + uniformNames.filter(n=>uniforms[n]===null).join(', ')));

// ============================================
// STATE
// ============================================
let currentSeed = 'calm';
let currentSeedFloat = seedToFloat(currentSeed);
let prevSeedFloat = currentSeedFloat;
let transition = 0;
let speedMul = 0.3;
let dpr = Math.min((window.devicePixelRatio || 1) * 0.5, 1); // start at half res
const targetDpr = Math.min(window.devicePixelRatio || 1, 2);
let dprRampTimer = 0;
let isMobile = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
let audioStarted = false;
let audioCtx = null;
let masterGain = null;
let altAudioFade = 1.0; // altitude-based audio fade (1=full, 0=silent)
let droneGainNodes = []; // store drone gain nodes for altitude modulation
let rainGainNode = null; // store rain gain node for altitude modulation

// Adaptive quality
let frameCount = 0;
let fpsAccum = 0;
let currentFps = 60;

// Camera state
let camX = 0, camY = 3.5, camZ = 0;
let camYaw = 0, camPitch = -0.15; // radians
let velX = 0, velY = 0, velZ = 0;
const moveSpeed = 8.0;
const mouseSens = 0.002;
const camDamping = 0.85;
let pointerLocked = false;
let flyMode = false; // true = WASD active, false = auto-drift
let idleTimer = 0;
const IDLE_TIMEOUT = 3.0; // seconds of no input before auto-drift resumes
let driftTime = 0; // accumulated drift time for altitude journey
let driftPhase = Math.random() * Math.PI * 2; // randomize starting phase

// Keyboard
const keys = {};
document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['KeyW','KeyA','KeyS','KeyD','Space','ShiftLeft','ShiftRight'].includes(e.code)) {
        flyMode = true;
        idleTimer = 0;
        e.preventDefault();
    }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Scroll wheel: adjust fly speed
let flySpeedMul = 5.0; // default to fast — feels better
document.addEventListener('wheel', e => {
    flySpeedMul *= e.deltaY < 0 ? 1.15 : 0.87;
    flySpeedMul = Math.max(0.1, Math.min(20.0, flySpeedMul));
    e.preventDefault();
}, { passive: false });

// ============================================
// SEED FROM URL HASH
// ============================================
function loadSeedFromHash() {
    const hash = window.location.hash.slice(1);
    if (hash) {
        currentSeed = decodeURIComponent(hash);
        currentSeedFloat = seedToFloat(currentSeed);
        prevSeedFloat = currentSeedFloat;
        document.getElementById('seed-input').value = currentSeed;
    } else {
        // Random seed on first load
        currentSeed = String(Math.floor(Math.random() * 99999));
        currentSeedFloat = seedToFloat(currentSeed);
        prevSeedFloat = currentSeedFloat;
    }
}
loadSeedFromHash();

window.addEventListener('hashchange', () => {
    const hash = window.location.hash.slice(1);
    if (hash) changeSeed(decodeURIComponent(hash));
});

function changeSeed(newSeed) {
    if (newSeed === currentSeed) return;
    prevSeedFloat = currentSeedFloat;
    currentSeed = newSeed;
    currentSeedFloat = seedToFloat(currentSeed);
    transition = 1.0;
    window.history.replaceState(null, '', '#' + encodeURIComponent(currentSeed));
}

// ============================================
// CONTROLS
// ============================================
const seedInput = document.getElementById('seed-input');
const speedSlider = document.getElementById('speed');
const volumeSlider = document.getElementById('volume');
const fsBtn = document.getElementById('fs-btn');
const audioBtn = document.getElementById('audio-btn');

seedInput.value = currentSeed;
seedInput.addEventListener('change', () => {
    const v = seedInput.value.trim();
    if (v) changeSeed(v);
});

speedSlider.addEventListener('input', () => {
    speedMul = speedSlider.value / 100;
});

volumeSlider.addEventListener('input', () => {
    if (masterGain) {
        masterGain.gain.setTargetAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime, 0.1);
    }
});

fsBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
    } else {
        document.exitFullscreen();
    }
});

audioBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleAudio();
});

// ============================================
// MOUSE / POINTER LOCK
// ============================================
document.addEventListener('mousemove', (e) => {
    if (pointerLocked) {
        camYaw += e.movementX * mouseSens;
        camPitch -= e.movementY * mouseSens;
        camPitch = Math.max(-1.4, Math.min(1.4, camPitch));
        if (Math.abs(e.movementX) + Math.abs(e.movementY) > 2) {
            idleTimer = 0;
            flyMode = true;
        }
    }
});

canvas.addEventListener('click', () => {
    if (!pointerLocked) {
        canvas.requestPointerLock();
    }
    if (!audioStarted) startAudio();
});

document.addEventListener('pointerlockchange', () => {
    pointerLocked = document.pointerLockElement === canvas;
    document.getElementById('crosshair').classList.toggle('active', pointerLocked);
});

// Mute when tab is hidden (minimized) — but keep playing on alt-tab (blur)
document.addEventListener('visibilitychange', () => {
    if (!audioCtx || !masterGain) return;
    if (document.hidden) {
        masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
        setTimeout(() => { if (document.hidden && audioCtx.state === 'running') audioCtx.suspend(); }, 500);
    } else {
        if (audioCtx.state === 'suspended' && audioStarted) {
            audioCtx.resume().then(() => {
                masterGain.gain.setTargetAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime, 0.5);
            });
        }
    }
});

document.addEventListener('touchmove', (e) => {
    const t = e.touches[0];
    camYaw = -((t.clientX / window.innerWidth) * 2 - 1) * 0.5;
    camPitch = -((t.clientY / window.innerHeight) * 2 - 1) * 0.3 - 0.15;
}, { passive: true });

document.addEventListener('touchstart', () => {
    if (!audioStarted) startAudio();
}, { passive: true });

// Show controls hint after 2s
setTimeout(() => {
    const hint = document.getElementById('controls-help');
    if (hint) { hint.classList.add('visible'); setTimeout(() => hint.classList.add('fade'), 6000); }
}, 2000);

// ============================================
// AUDIO SYSTEM
// ============================================
function startAudio() {
    if (audioStarted) return;
    audioStarted = true;

    document.getElementById('audio-icon-on').style.display = 'block';
    document.getElementById('audio-icon-off').style.display = 'none';

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Master gain — fade in over 3s
    masterGain = audioCtx.createGain();
    masterGain.gain.setValueAtTime(0, audioCtx.currentTime);
    masterGain.gain.linearRampToValueAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime + 3);
    masterGain.connect(audioCtx.destination);

    // Reverb (procedural impulse, same pattern as lofigen)
    const reverbLength = audioCtx.sampleRate * 4;
    const impulse = audioCtx.createBuffer(2, reverbLength, audioCtx.sampleRate);
    const rr = mulberry32(currentSeed + '_reverb');
    for (let ch = 0; ch < 2; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < reverbLength; i++) {
            const t = i / reverbLength;
            let val = rr() * 2 - 1;
            if (t < 0.05) val *= 0.7;
            val *= Math.exp(-3.0 * t);
            if (t > 0.2) val *= 0.8;
            data[i] = val;
        }
    }
    const reverb = audioCtx.createConvolver();
    reverb.buffer = impulse;

    const reverbGain = audioCtx.createGain();
    reverbGain.gain.value = 0.4;
    reverb.connect(reverbGain);
    reverbGain.connect(masterGain);

    const dryBus = audioCtx.createGain();
    dryBus.gain.value = 0.6;
    dryBus.connect(masterGain);

    const reverbSend = audioCtx.createGain();
    reverbSend.gain.value = 0.5;
    reverbSend.connect(reverb);

    // --- Drone pad: 2 detuned oscillators ---
    function createDrone(freq, type) {
        const osc = audioCtx.createOscillator();
        osc.type = type;
        osc.frequency.value = freq;

        const lpf = audioCtx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.value = 300;
        lpf.Q.value = 1;

        // Slow LPF sweep
        const now = audioCtx.currentTime;
        lpf.frequency.setValueAtTime(200, now);
        function sweepLPF() {
            const t = audioCtx.currentTime;
            lpf.frequency.linearRampToValueAtTime(400 + Math.sin(t * 0.05) * 200, t + 8);
            setTimeout(sweepLPF, 8000);
        }
        sweepLPF();

        const gain = audioCtx.createGain();
        gain.gain.value = 0.06; // quiet drones, spatial emitters are the star

        osc.connect(lpf);
        lpf.connect(gain);
        gain.connect(dryBus);
        gain.connect(reverbSend);
        osc.start();
        droneGainNodes.push(gain);
        return osc;
    }

    // Two drones at ~55Hz (A1) detuned — quieter to let spatial audio breathe
    createDrone(55, 'sine');
    createDrone(55.3, 'triangle');
    createDrone(27.5, 'sine');

    // --- Rain texture: filtered noise ---
    const rainLen = audioCtx.sampleRate * 4;
    const rainBuf = audioCtx.createBuffer(1, rainLen, audioCtx.sampleRate);
    const rainData = rainBuf.getChannelData(0);
    const rainRng = mulberry32(currentSeed + '_rain');
    for (let i = 0; i < rainLen; i++) rainData[i] = rainRng() * 2 - 1;

    const rainSrc = audioCtx.createBufferSource();
    rainSrc.buffer = rainBuf;
    rainSrc.loop = true;

    const rainBP = audioCtx.createBiquadFilter();
    rainBP.type = 'bandpass';
    rainBP.frequency.value = 3000;
    rainBP.Q.value = 0.5;

    const rainHP = audioCtx.createBiquadFilter();
    rainHP.type = 'highpass';
    rainHP.frequency.value = 800;

    const rainGain = audioCtx.createGain();
    rainGain.gain.value = 0.02;
    rainGainNode = rainGain;

    rainSrc.connect(rainBP);
    rainBP.connect(rainHP);
    rainHP.connect(rainGain);
    rainGain.connect(dryBus);
    rainSrc.start();

    // --- Sparse pentatonic tones ---
    const pentatonic = [0, 2, 4, 7, 9]; // relative to root
    const rootMidi = 60; // C4
    const toneRng = mulberry32(currentSeed + '_tones');

    function scheduleTone() {
        const delay = 5 + toneRng() * 10; // 5-15s between tones
        setTimeout(() => {
            if (!audioCtx || audioCtx.state === 'closed') return;

            const degree = pentatonic[Math.floor(toneRng() * pentatonic.length)];
            const octave = Math.floor(toneRng() * 2); // 0 or 1 octave up
            const midi = rootMidi + degree + octave * 12;
            const freq = 440 * Math.pow(2, (midi - 69) / 12);

            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;

            const env = audioCtx.createGain();
            const now = audioCtx.currentTime;
            const dur = 3 + toneRng() * 5;
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.03 + toneRng() * 0.02, now + dur * 0.3);
            env.gain.linearRampToValueAtTime(0, now + dur);

            osc.connect(env);
            env.connect(dryBus);
            env.connect(reverbSend);
            osc.start(now);
            osc.stop(now + dur + 0.1);

            scheduleTone();
        }, delay * 1000);
    }
    scheduleTone();

    // Init spatial emitters after audio context is ready
    initSpatialAudio();
}

// ============================================
// SPATIAL AUDIO EMITTER SYSTEM
// ============================================
// Deterministic hash for cell IDs (must be stable for same inputs)
function cellHash(cx, cz, sd, salt) {
    let v = Math.sin(cx * 127.1 + cz * 311.7 + sd * salt) * 43758.5453;
    return v - Math.floor(v);
}

// Pentatonic scale notes for musical emitters (A minor pentatonic across octaves)
const PENTA = [55, 65.41, 73.42, 82.41, 98, 110, 130.81, 146.83, 164.81, 196,
               220, 261.63, 293.66, 329.63, 392, 440, 523.25, 587.33, 659.25, 783.99];

const EMITTER_POOL_SIZE = 12;
let emitterPool = [];
let spatialBus = null;
let spatialReverbSend = null;
let spatialDebugTimer = 0;
let spatialDebugCount = 0;

function initSpatialAudio() {
    if (!audioCtx || !masterGain) return;

    // Spatial bus — loud enough to hear clearly
    spatialBus = audioCtx.createGain();
    spatialBus.gain.value = 1.0;
    spatialBus.connect(masterGain);

    // Spatial reverb send (reuse main reverb if available, otherwise make one)
    spatialReverbSend = audioCtx.createGain();
    spatialReverbSend.gain.value = 0.3;
    spatialReverbSend.connect(masterGain); // fallback direct

    // Create emitter pool — each emitter has rich sound design
    for (let i = 0; i < EMITTER_POOL_SIZE; i++) {
        // StereoPanner for simple L/R positioning (reliable, no HRTF issues)
        const pan = audioCtx.createStereoPanner();
        pan.pan.value = 0;

        // Main gain (distance-based)
        const gain = audioCtx.createGain();
        gain.gain.value = 0;

        // LPF for distance occlusion
        const lpf = audioCtx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.value = 4000;
        lpf.Q.value = 0.5;

        // 3 oscillators for rich harmonics (fundamental + 5th + octave)
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const osc3 = audioCtx.createOscillator();
        osc1.type = 'sine'; osc1.frequency.value = 0.001;
        osc2.type = 'sine'; osc2.frequency.value = 0.001;
        osc3.type = 'sine'; osc3.frequency.value = 0.001;

        const g1 = audioCtx.createGain(); g1.gain.value = 0.5;
        const g2 = audioCtx.createGain(); g2.gain.value = 0.25;
        const g3 = audioCtx.createGain(); g3.gain.value = 0.15;

        // LFO for gentle vibrato
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine'; lfo.frequency.value = 0.1;
        const lfoG = audioCtx.createGain();
        lfoG.gain.value = 0;
        lfo.connect(lfoG);
        lfoG.connect(osc1.frequency);
        lfoG.connect(osc2.frequency);
        lfoG.connect(osc3.frequency);

        osc1.connect(g1); osc2.connect(g2); osc3.connect(g3);
        g1.connect(lpf); g2.connect(lpf); g3.connect(lpf);
        lpf.connect(gain);
        gain.connect(pan);
        pan.connect(spatialBus);
        pan.connect(spatialReverbSend);

        lfo.start(); osc1.start(); osc2.start(); osc3.start();

        emitterPool.push({
            pan, gain, lpf, osc1, osc2, osc3, g1, g2, g3, lfo, lfoG,
            key: null, type: 0, targetGain: 0, curGain: 0,
        });
    }
    dbg(true, `Spatial audio: ${EMITTER_POOL_SIZE} emitters ready`);
}

// Find nearby sound-emitting objects
function findNearbyObjects(cx, cy, cz, sd) {
    const objs = [];

    // Spheres (cell=40, ~40% density)
    const sp = 40;
    const sx0 = Math.floor(cx / sp), sz0 = Math.floor(cz / sp);
    for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) {
        const gx = sx0+dx, gz = sz0+dz;
        const h = cellHash(gx, gz, sd, 31);
        if (h < 0.4) {
            const ox = gx*sp + sp*0.5 + (h*2-1)*10;
            const oz = gz*sp + sp*0.5 + ((h*7.7%1)*2-1)*10;
            const d = Math.hypot(cx-ox, cy-3, cz-oz);
            if (d < 80) objs.push({type:1, x:ox, y:3, z:oz, d, key:`s${gx}_${gz}`, h});
        }
    }

    // Crystals (cell=30, ~15% density)
    const cr = 30;
    const cx0 = Math.floor(cx / cr), cz0 = Math.floor(cz / cr);
    for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) {
        const gx = cx0+dx, gz = cz0+dz;
        const h = cellHash(gx, gz, sd, 59);
        if (h < 0.15) {
            const ox = gx*cr + cr*0.5 + (h*2-1)*8;
            const oz = gz*cr + cr*0.5 + ((h*11%1)*2-1)*8;
            const d = Math.hypot(cx-ox, cy-4, cz-oz);
            if (d < 60) objs.push({type:4, x:ox, y:4, z:oz, d, key:`x${gx}_${gz}`, h});
        }
    }

    // Cairns (cell=55, ~12% density)
    const ca = 55;
    const ca0 = Math.floor(cx / ca), caz = Math.floor(cz / ca);
    for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) {
        const gx = ca0+dx, gz = caz+dz;
        const h = cellHash(gx, gz, sd, 83);
        if (h < 0.12) {
            const ox = gx*ca + ca*0.5 + (h*2-1)*15;
            const oz = gz*ca + ca*0.5 + ((h*9%1)*2-1)*15;
            const d = Math.hypot(cx-ox, cy-3, cz-oz);
            if (d < 70) objs.push({type:5, x:ox, y:3, z:oz, d, key:`n${gx}_${gz}`, h});
        }
    }

    // Structures (cell=120, ~25% density)
    const bg = 120;
    const bg0 = Math.floor(cx / bg), bgz = Math.floor(cz / bg);
    for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) {
        const gx = bg0+dx, gz = bgz+dz;
        const h = cellHash(gx, gz, sd, 73);
        if (h < 0.25) {
            const ox = gx*bg + bg*0.5 + (h*2-1)*30;
            const oz = gz*bg + bg*0.5 + ((h*13.37%1)*2-1)*30;
            const d = Math.hypot(cx-ox, cy-6, cz-oz);
            if (d < 100) objs.push({type:3, x:ox, y:6, z:oz, d, key:`b${gx}_${gz}`, h});
        }
    }

    objs.sort((a,b) => a.d - b.d);
    return objs;
}

// Configure emitter sound based on object type
function configureEmitter(em, obj) {
    const now = audioCtx.currentTime;
    const t = 0.8; // transition time

    // Pick pentatonic note based on object hash
    const noteIdx = Math.floor(obj.h * PENTA.length);
    const baseFreq = PENTA[noteIdx];

    if (obj.type === 1) {
        // Spheres: warm pad — fundamental + major 3rd + octave, sine, slow vibrato
        em.osc1.type = 'sine';
        em.osc2.type = 'sine';
        em.osc3.type = 'triangle';
        em.osc1.frequency.setTargetAtTime(baseFreq, now, t);
        em.osc2.frequency.setTargetAtTime(baseFreq * 1.26, now, t); // ~major 3rd
        em.osc3.frequency.setTargetAtTime(baseFreq * 2.0, now, t); // octave
        em.g1.gain.setTargetAtTime(0.5, now, t);
        em.g2.gain.setTargetAtTime(0.2, now, t);
        em.g3.gain.setTargetAtTime(0.1, now, t);
        em.lfo.frequency.setTargetAtTime(0.15 + obj.h * 0.1, now, t);
        em.lfoG.gain.setTargetAtTime(baseFreq * 0.008, now, t);
        em.lpf.frequency.setTargetAtTime(800, now, t);
    } else if (obj.type === 3) {
        // Structures: deep organ drone — low note + 5th + sub
        const low = Math.max(baseFreq * 0.25, 30);
        em.osc1.type = 'sine';
        em.osc2.type = 'triangle';
        em.osc3.type = 'sine';
        em.osc1.frequency.setTargetAtTime(low, now, t);
        em.osc2.frequency.setTargetAtTime(low * 1.5, now, t); // 5th
        em.osc3.frequency.setTargetAtTime(low * 0.5, now, t); // sub octave
        em.g1.gain.setTargetAtTime(0.4, now, t);
        em.g2.gain.setTargetAtTime(0.2, now, t);
        em.g3.gain.setTargetAtTime(0.3, now, t);
        em.lfo.frequency.setTargetAtTime(0.04 + obj.h * 0.03, now, t);
        em.lfoG.gain.setTargetAtTime(low * 0.01, now, t);
        em.lpf.frequency.setTargetAtTime(400, now, t);
    } else if (obj.type === 4) {
        // Crystals: bell/chime — high note + inharmonic partials
        const hi = Math.min(baseFreq * 2, 2000);
        em.osc1.type = 'sine';
        em.osc2.type = 'sine';
        em.osc3.type = 'sine';
        em.osc1.frequency.setTargetAtTime(hi, now, t);
        em.osc2.frequency.setTargetAtTime(hi * 2.76, now, t); // inharmonic (bell-like)
        em.osc3.frequency.setTargetAtTime(hi * 5.4, now, t); // higher partial
        em.g1.gain.setTargetAtTime(0.35, now, t);
        em.g2.gain.setTargetAtTime(0.15, now, t);
        em.g3.gain.setTargetAtTime(0.05, now, t);
        em.lfo.frequency.setTargetAtTime(1.5 + obj.h * 2, now, t);
        em.lfoG.gain.setTargetAtTime(hi * 0.003, now, t);
        em.lpf.frequency.setTargetAtTime(6000, now, t);
    } else if (obj.type === 5) {
        // Cairns: earthy hum — low triangle + sub sine
        const lo = Math.max(baseFreq * 0.5, 40);
        em.osc1.type = 'triangle';
        em.osc2.type = 'sine';
        em.osc3.type = 'sine';
        em.osc1.frequency.setTargetAtTime(lo, now, t);
        em.osc2.frequency.setTargetAtTime(lo * 2.0, now, t);
        em.osc3.frequency.setTargetAtTime(lo * 0.5, now, t);
        em.g1.gain.setTargetAtTime(0.4, now, t);
        em.g2.gain.setTargetAtTime(0.15, now, t);
        em.g3.gain.setTargetAtTime(0.25, now, t);
        em.lfo.frequency.setTargetAtTime(0.08 + obj.h * 0.06, now, t);
        em.lfoG.gain.setTargetAtTime(lo * 0.012, now, t);
        em.lpf.frequency.setTargetAtTime(500, now, t);
    }
}

function updateSpatialAudio(dt, elapsed) {
    if (!audioCtx || audioCtx.state !== 'running' || emitterPool.length === 0) return;

    const nearby = findNearbyObjects(camX, camY, camZ, currentSeedFloat);
    const now = audioCtx.currentTime;

    // Debug: log every 3 seconds
    spatialDebugTimer += dt;
    if (spatialDebugTimer > 3) {
        spatialDebugTimer = 0;
        const active = emitterPool.filter(e => e.curGain > 0.001).length;
        if (spatialDebugCount < 5) {
            dbg(nearby.length > 0, `Spatial: ${nearby.length} objects found, ${active} emitters active, closest: ${nearby[0] ? nearby[0].d.toFixed(1) + 'm type=' + nearby[0].type : 'none'}`);
            spatialDebugCount++;
        }
    }

    // Camera forward vector (for stereo panning)
    const fwdX = Math.sin(camYaw);
    const fwdZ = Math.cos(camYaw);
    const rightX = Math.cos(camYaw);
    const rightZ = -Math.sin(camYaw);

    // Build set of keys we want active
    const wantKeys = new Map(); // key -> obj
    for (let i = 0; i < Math.min(nearby.length, EMITTER_POOL_SIZE); i++) {
        wantKeys.set(nearby[i].key, nearby[i]);
    }

    // Release emitters not in want list
    for (const em of emitterPool) {
        if (em.key && !wantKeys.has(em.key)) {
            em.key = null;
            em.targetGain = 0;
        }
    }

    // Assign wanted objects to emitters
    for (const [key, obj] of wantKeys) {
        // Already assigned?
        let em = emitterPool.find(e => e.key === key);
        if (em) {
            // Update existing
        } else {
            // Find free emitter
            em = emitterPool.find(e => !e.key);
            if (!em) continue; // pool full
            em.key = key;
            em.type = obj.type;
            configureEmitter(em, obj);
        }

        // Distance attenuation — louder close, silent far
        const maxDist = 60;
        const norm = Math.min(obj.d / maxDist, 1);
        const vol = (1 - norm) * (1 - norm); // quadratic falloff, 1.0 at origin
        em.targetGain = vol * 0.35; // max volume per emitter

        // LPF drops with distance
        const baseLpf = em.type === 4 ? 6000 : em.type === 3 ? 400 : 1200;
        em.lpf.frequency.setTargetAtTime(Math.max(baseLpf * (1 - norm * 0.8), 150), now, 0.3);

        // Stereo pan based on direction relative to camera
        const dx = obj.x - camX, dz = obj.z - camZ;
        const dot = dx * rightX + dz * rightZ; // project onto camera right
        const panVal = Math.max(-1, Math.min(1, dot / Math.max(obj.d, 1)));
        em.pan.pan.setTargetAtTime(panVal, now, 0.1);
    }

    // Smooth all gains
    for (const em of emitterPool) {
        em.curGain += (em.targetGain - em.curGain) * (1 - Math.exp(-5 * dt));
        em.gain.gain.setTargetAtTime(Math.max(em.curGain, 0.0001), now, 0.05);
    }
}

function toggleAudio() {
    if (!audioStarted) {
        startAudio();
        return;
    }
    if (!audioCtx) return;

    const onIcon = document.getElementById('audio-icon-on');
    const offIcon = document.getElementById('audio-icon-off');

    if (audioCtx.state === 'running') {
        masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
        setTimeout(() => audioCtx.suspend(), 500);
        onIcon.style.display = 'none';
        offIcon.style.display = 'block';
    } else {
        audioCtx.resume();
        masterGain.gain.setTargetAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime, 0.3);
        onIcon.style.display = 'block';
        offIcon.style.display = 'none';
    }
}

// ============================================
// RESIZE + ADAPTIVE QUALITY
// ============================================
function resize() {
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    canvas.width = w;
    canvas.height = h;
    gl.viewport(0, 0, w, h);
    dbg(w > 0 && h > 0, `Canvas resized: ${w}x${h} (dpr=${dpr})`);
}

window.addEventListener('resize', resize);
resize();

dbg(true, `Seed: "${currentSeed}" -> float: ${currentSeedFloat}`);
dbg(!isMobile, `Device: ${isMobile ? 'mobile' : 'desktop'}`);

// ============================================
// HUD ELEMENTS
// ============================================
const hudFps = document.getElementById('hud-fps');
const hudRes = document.getElementById('hud-res');
const hudSeed = document.getElementById('hud-seed');
const hudDpr = document.getElementById('hud-dpr');
const hudPos = document.getElementById('hud-pos');
const hudYaw = document.getElementById('hud-yaw');
const hudTime = document.getElementById('hud-time');
const hudMode = document.getElementById('hud-mode');
const hudSpeed = document.getElementById('hud-speed');
const breathFill = document.getElementById('breath-fill');

// Altitude graph
const altCanvas = document.getElementById('alt-canvas');
const altCtx = altCanvas.getContext('2d');
const ALT_HISTORY_LEN = 200;
const altHistory = new Float32Array(ALT_HISTORY_LEN); // ring buffer
let altHistIdx = 0;
const ALT_MAX = 150; // max altitude for graph scale

// ============================================
// AMBIENT CLOCK
// ============================================
const clockEl = document.getElementById('ambient-clock');
function updateClock() {
    const d = new Date();
    const h = d.getHours() % 12 || 12;
    const m = String(d.getMinutes()).padStart(2, '0');
    clockEl.textContent = `${h}:${m}`;
}
updateClock();
setInterval(updateClock, 10000);
// Fade in after 5s
setTimeout(() => clockEl.classList.add('visible'), 5000);

// ============================================
// QUOTES
// ============================================
const quotes = [
    "breathe in. breathe out.",
    "you are exactly where you need to be.",
    "the present moment is all there is.",
    "let the thoughts drift by like clouds.",
    "nothing to fix. nothing to solve. just be.",
    "the mind is like water — calm it and everything becomes clear.",
    "rest is not idleness.",
    "you don't have to figure it all out today.",
    "between stimulus and response there is a space.",
    "be still and know.",
    "progress is not always visible.",
    "the quieter you become, the more you can hear.",
    "this too shall pass.",
    "you are not your thoughts.",
    "slow down. you're doing fine.",
    "one breath at a time.",
];
const quoteEl = document.getElementById('quote');
let quoteIdx = Math.floor(Math.random() * quotes.length);
function showQuote() {
    quoteEl.classList.remove('visible');
    setTimeout(() => {
        quoteEl.textContent = quotes[quoteIdx % quotes.length];
        quoteIdx++;
        quoteEl.classList.add('visible');
        // Fade out after 12s
        setTimeout(() => quoteEl.classList.remove('visible'), 12000);
    }, 4000);
}
// First quote after 10s, then every 45-90s
setTimeout(showQuote, 10000);
setInterval(showQuote, 45000 + Math.random() * 45000);

// ============================================
// POMODORO TIMER
// ============================================
const pomoDisplay = document.getElementById('pomo-display');
const pomoLabel = document.getElementById('pomo-label');
const pomoFill = document.getElementById('pomo-fill');
const pomoBtn = document.getElementById('pomo-btn');

let pomoState = 'idle'; // idle, focus, break
let pomoRemaining = 25 * 60; // seconds
let pomoTotal = 25 * 60;
let pomoInterval = null;
let pomoSessions = 0;

const FOCUS_MINUTES = 25;
const SHORT_BREAK = 5;
const LONG_BREAK = 15;

function formatPomo(secs) {
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    return `${m}:${String(s).padStart(2, '0')}`;
}

function pomoPing() {
    // Gentle audio cue if audio is active
    if (audioCtx && audioCtx.state === 'running') {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 528; // solfeggio
        const env = audioCtx.createGain();
        const now = audioCtx.currentTime;
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.08, now + 0.3);
        env.gain.linearRampToValueAtTime(0, now + 2.5);
        osc.connect(env);
        env.connect(masterGain);
        osc.start(now);
        osc.stop(now + 3);
        // Second tone
        setTimeout(() => {
            const osc2 = audioCtx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 639;
            const env2 = audioCtx.createGain();
            const n2 = audioCtx.currentTime;
            env2.gain.setValueAtTime(0, n2);
            env2.gain.linearRampToValueAtTime(0.06, n2 + 0.3);
            env2.gain.linearRampToValueAtTime(0, n2 + 2);
            osc2.connect(env2);
            env2.connect(masterGain);
            osc2.start(n2);
            osc2.stop(n2 + 2.5);
        }, 800);
    }
}

function startPomo() {
    if (pomoState === 'idle' || pomoState === 'done') {
        pomoState = 'focus';
        pomoTotal = FOCUS_MINUTES * 60;
        pomoRemaining = pomoTotal;
        pomoLabel.textContent = 'focus';
        pomoFill.style.background = 'rgba(180,170,160,0.3)';
        pomoBtn.textContent = 'stop';
    } else if (pomoState === 'focus' || pomoState === 'break') {
        // Stop
        clearInterval(pomoInterval);
        pomoInterval = null;
        pomoState = 'idle';
        pomoRemaining = FOCUS_MINUTES * 60;
        pomoTotal = pomoRemaining;
        pomoLabel.textContent = 'focus';
        pomoBtn.textContent = 'start';
        pomoDisplay.textContent = formatPomo(pomoRemaining);
        pomoFill.style.width = '0%';
        return;
    }

    clearInterval(pomoInterval);
    pomoInterval = setInterval(() => {
        pomoRemaining--;
        if (pomoRemaining <= 0) {
            clearInterval(pomoInterval);
            pomoPing();

            if (pomoState === 'focus') {
                pomoSessions++;
                // Switch to break
                pomoState = 'break';
                const breakLen = (pomoSessions % 4 === 0) ? LONG_BREAK : SHORT_BREAK;
                pomoTotal = breakLen * 60;
                pomoRemaining = pomoTotal;
                pomoLabel.textContent = (pomoSessions % 4 === 0) ? 'long break' : 'break';
                pomoFill.style.background = 'rgba(120,180,140,0.3)';
                pomoBtn.textContent = 'skip';
                // Auto-start break
                pomoInterval = setInterval(arguments.callee, 1000);
            } else {
                // Break done
                pomoState = 'done';
                pomoLabel.textContent = 'done';
                pomoBtn.textContent = 'start';
                pomoPing();
            }
        }
        pomoDisplay.textContent = formatPomo(pomoRemaining);
        const pct = ((pomoTotal - pomoRemaining) / pomoTotal) * 100;
        pomoFill.style.width = `${pct}%`;
    }, 1000);
}

pomoBtn.addEventListener('click', startPomo);
pomoDisplay.textContent = formatPomo(pomoRemaining);

// ============================================
// RENDER LOOP
// ============================================
const startTime = performance.now();
let lastFrame = startTime;
let debugFrames = 0;
let hudTimer = 0;

function frame(now) {
    requestAnimationFrame(frame);
    debugFrames++;
    if (debugFrames === 1) dbg(true, 'First frame rendering');
    if (debugFrames === 5) {
        const err = gl.getError();
        dbg(err === gl.NO_ERROR, `WebGL error check: ${err === gl.NO_ERROR ? 'none' : 'ERROR ' + err}`);
        const px = new Uint8Array(4);
        gl.readPixels(Math.floor(canvas.width/2), Math.floor(canvas.height/2), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
        const bright = px[0] + px[1] + px[2];
        dbg(bright > 0, `Center pixel: rgb(${px[0]},${px[1]},${px[2]}) — ${bright > 0 ? 'visible' : 'BLACK'}`);
    }

    const dt = Math.min((now - lastFrame) / 1000, 0.1); // cap dt
    lastFrame = now;

    // Ramp DPR up over first 3 seconds for smooth startup
    dprRampTimer += dt;
    if (dprRampTimer < 3.0 && dpr < targetDpr) {
        dpr = Math.min(targetDpr, dpr + dt * (targetDpr / 3.0));
        resize();
    }

    // Adaptive FPS check
    frameCount++;
    fpsAccum += dt;
    if (fpsAccum > 1) {
        currentFps = Math.round(frameCount / fpsAccum);
        if (currentFps < 28 && dpr > 0.5) {
            dpr = Math.max(0.5, dpr - 0.25);
            resize();
        }
        frameCount = 0;
        fpsAccum = 0;
    }

    const elapsed = (now - startTime) / 1000;
    const time = elapsed * speedMul;

    // ---- Camera ----
    // Forward/right vectors from yaw (horizontal plane, matches shader cam)
    const fwdX = Math.sin(camYaw);
    const fwdZ = Math.cos(camYaw);
    const rightX = Math.cos(camYaw);
    const rightZ = -Math.sin(camYaw);

    // Check for any active input
    const anyInput = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'] ||
                     keys['Space'] || keys['ShiftLeft'] || keys['ShiftRight'];

    if (flyMode && anyInput) {
        idleTimer = 0;
    } else if (flyMode) {
        idleTimer += dt;
        if (idleTimer >= IDLE_TIMEOUT) {
            flyMode = false;
            // Don't snap — drift will continue from current position
            // Keep driftTime rolling so the journey continues seamlessly
        }
    }

    if (flyMode) {
        // WASD input
        let inputX = 0, inputY = 0, inputZ = 0;
        if (keys['KeyW']) { inputX += fwdX; inputZ += fwdZ; }
        if (keys['KeyS']) { inputX -= fwdX; inputZ -= fwdZ; }
        if (keys['KeyD']) { inputX += rightX; inputZ += rightZ; }
        if (keys['KeyA']) { inputX -= rightX; inputZ -= rightZ; }
        if (keys['Space']) inputY += 1;
        if (keys['ShiftLeft'] || keys['ShiftRight']) inputY -= 1;

        const len = Math.sqrt(inputX*inputX + inputY*inputY + inputZ*inputZ);
        if (len > 0) {
            const spd = moveSpeed * flySpeedMul;
            velX += (inputX/len) * spd * dt;
            velY += (inputY/len) * spd * dt;
            velZ += (inputZ/len) * spd * dt;
        }

        velX *= camDamping;
        velY *= camDamping;
        velZ *= camDamping;

        camX += velX * dt * 10;
        camY += velY * dt * 10;
        camZ += velZ * dt * 10;
    } else {
        // Auto-drift with altitude journey — ground to space and back
        driftTime += dt;
        const driftSpeed = 2.0 * flySpeedMul;
        camX += Math.sin(camYaw) * driftSpeed * dt;
        camZ += Math.cos(camYaw) * driftSpeed * dt;

        // Altitude: mostly low terrain-skimming waves (y=2-15),
        // rare quick space trips that punch through and come right back
        const t1 = driftTime / 20.0 + driftPhase;       // ~20s gentle bob
        const t2 = driftTime / 7.0 + driftPhase * 1.7;  // ~7s faster ripple
        const t3 = driftTime / 120.0 + driftPhase * 0.3; // ~120s rare space trigger

        // Low wave: gentle terrain-skimming between y=2 and y=12
        const lowWave = (Math.sin(t1 * Math.PI * 2) * 0.5
                       + Math.sin(t2 * Math.PI * 2) * 0.25) * 0.5 + 0.5; // 0 to 1
        const lowY = 2.0 + lowWave * 10.0; // y = 2 to 12

        // Space spike: sharp gaussian-ish pulse, only triggers briefly
        const spaceRaw = Math.sin(t3 * Math.PI * 2);
        // Only spike when spaceRaw > 0.85 — that's ~10% of the cycle
        const spaceGate = Math.max(0, (spaceRaw - 0.85) / 0.15); // 0 to 1, sharp
        const spacePulse = spaceGate * spaceGate; // sharper
        const spaceY = spacePulse * 130.0; // up to 130 in space

        const targetY = lowY + spaceY;

        // Smooth approach — faster when far from target for snappy space trips
        const altErr = Math.abs(targetY - camY);
        const lerpRate = altErr > 20 ? 1.5 : 0.8;
        camY += (targetY - camY) * lerpRate * dt;

        // Yaw drift
        camYaw += dt * 0.02;

        // Pitch follows altitude smoothly — look up when climbing, down when descending
        const altDelta = targetY - camY;
        const pitchTarget = Math.max(-0.6, Math.min(0.3, altDelta * 0.02));
        camPitch += (pitchTarget - camPitch) * 0.8 * dt;
    }

    // Floor clamp — allow slightly underground but not fully
    if (camY < -2.0) {
        camY = -2.0;
        if (velY < 0) velY = 0;
    }

    // Build camera basis vectors (with pitch)
    const cp = Math.cos(camPitch), sp = Math.sin(camPitch);
    const cy = Math.cos(camYaw), sy = Math.sin(camYaw);
    // Forward (into screen)
    const cfX = sy * cp;
    const cfY = sp;
    const cfZ = cy * cp;
    // Right
    const crX = cy;
    const crY = 0;
    const crZ = -sy;
    // Up = forward x right
    const cuX = cfY*crZ - cfZ*crY;
    const cuY = cfZ*crX - cfX*crZ;
    const cuZ = cfX*crY - cfY*crX;

    // Breathing cycle: 12s period — faster when moving faster
    const breathRate = 1.0 + (flySpeedMul - 1.0) * 0.5; // scale pulse speed with fly speed
    const breath = Math.sin(elapsed * Math.PI * 2 / 12 * breathRate);

    // Seed transition crossfade
    if (transition > 0) {
        transition = Math.max(0, transition - dt / 2.5);
    }

    // ---- Uniforms ----
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform1f(uTime, elapsed);
    gl.uniform1f(uSpeed, speedMul * breathRate);
    gl.uniform3f(uCamPos, camX, camY, camZ);
    gl.uniform3f(uCamFwd, cfX, cfY, cfZ);
    gl.uniform3f(uCamRight, crX, crY, crZ);
    gl.uniform3f(uCamUp, cuX, cuY, cuZ);
    gl.uniform1f(uBreath, breath);
    gl.uniform1f(uSeed, currentSeedFloat);
    gl.uniform1f(uTransition, transition);
    gl.uniform1f(uPrevSeed, prevSeedFloat);
    gl.uniform1f(uMobile, isMobile ? 1.0 : 0.0);
    // Velocity magnitude for speed lines
    const camVelocity = Math.sqrt(velX*velX + velY*velY + velZ*velZ) * 10;
    // In drift mode, use drift speed
    const effectiveVel = flyMode ? camVelocity : 2.0 * flySpeedMul + Math.abs(camY - 3.5) * 0.1;
    gl.uniform1f(uVelocity, effectiveVel);

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    // ---- Altitude-based audio mix ----
    // Ground (0-10): full volume. Clouds (10-40): muffle + wind. Upper atmo (40-100): fading. Space (100+): silence.
    if (audioCtx && masterGain && audioCtx.state === 'running') {
        const alt = Math.max(camY, 0);
        const now2 = audioCtx.currentTime;

        // Spatial emitters fade: full at ground, gone by y=80
        const spatialFade = Math.max(0, 1 - alt / 80);
        if (spatialBus) spatialBus.gain.setTargetAtTime(spatialFade * spatialFade, now2, 0.3);

        // Drones: muffle in clouds (LPF feel via volume dip), fade out by space
        // In clouds (15-40): reduce to 60%. Above 40: fade to 0 by y=120
        const droneFade = alt < 15 ? 1.0 : alt < 40 ? 0.6 : Math.max(0, 1 - (alt - 15) / 105);
        for (const dg of droneGainNodes) {
            dg.gain.setTargetAtTime(0.06 * droneFade, now2, 0.5);
        }

        // Rain: gets louder in clouds (wind!), fades in upper atmosphere
        const rainFade = alt < 10 ? 1.0 : alt < 40 ? 1.8 : Math.max(0, 1 - (alt - 40) / 60);
        if (rainGainNode) rainGainNode.gain.setTargetAtTime(0.02 * rainFade, now2, 0.5);

        altAudioFade = Math.max(0, 1 - Math.max(0, alt - 15) / 120);
    }

    // ---- Spatial audio update ----
    updateSpatialAudio(dt, elapsed);

    // ---- HUD update (throttled) ----
    hudTimer += dt;
    if (hudTimer > 0.2) {
        hudTimer = 0;
        hudFps.textContent = `${currentFps} fps`;
        hudRes.textContent = `${canvas.width}x${canvas.height}`;
        hudSeed.textContent = `seed: ${currentSeed}`;
        hudDpr.textContent = `dpr: ${dpr.toFixed(2)}`;
        hudPos.textContent = `pos: ${camX.toFixed(1)}, ${camY.toFixed(1)}, ${camZ.toFixed(1)}`;
        hudYaw.textContent = `yaw: ${(camYaw*180/Math.PI).toFixed(0)} pitch: ${(camPitch*180/Math.PI).toFixed(0)}`;
        hudTime.textContent = `time: ${elapsed.toFixed(1)}s`;
        const zone = camY < 0 ? 'underground' : camY < 15 ? 'surface' : camY < 50 ? 'clouds' : camY < 120 ? 'upper atmosphere' : 'space';
        hudMode.textContent = `mode: ${flyMode ? 'fly' : 'drift'}${pointerLocked ? ' [locked]' : ''} | ${zone}`;
        hudSpeed.textContent = `speed: ${flySpeedMul.toFixed(1)}x`;
        const activeEmitters = emitterPool.filter(e => e.key && e.curGain > 0.001).length;
        hudDpr.textContent = `dpr: ${dpr.toFixed(2)} | emitters: ${activeEmitters}/${EMITTER_POOL_SIZE}`;
        breathFill.style.width = `${(breath * 0.5 + 0.5) * 100}%`;

        // Altitude graph
        altHistory[altHistIdx % ALT_HISTORY_LEN] = Math.max(0, camY);
        altHistIdx++;
        const aw = altCanvas.width, ah = altCanvas.height;
        altCtx.clearRect(0, 0, aw, ah);

        // Zone bands (ground, clouds, upper atmo, space)
        const zones = [
            { y: 0, h: 15, color: 'rgba(100,180,100,0.08)' },
            { y: 15, h: 35, color: 'rgba(180,180,200,0.08)' },
            { y: 50, h: 70, color: 'rgba(100,120,200,0.06)' },
            { y: 120, h: 30, color: 'rgba(40,20,80,0.06)' },
        ];
        for (const z of zones) {
            const top = ah - (z.y + z.h) / ALT_MAX * ah;
            const height = z.h / ALT_MAX * ah;
            altCtx.fillStyle = z.color;
            altCtx.fillRect(0, Math.max(0, top), aw, height);
        }

        // Draw altitude line
        altCtx.strokeStyle = 'rgba(220,215,200,0.6)';
        altCtx.lineWidth = 1.5;
        altCtx.beginPath();
        for (let i = 0; i < ALT_HISTORY_LEN; i++) {
            const idx = (altHistIdx + i) % ALT_HISTORY_LEN;
            const x = (i / ALT_HISTORY_LEN) * aw;
            const y = ah - (altHistory[idx] / ALT_MAX) * ah;
            if (i === 0) altCtx.moveTo(x, y); else altCtx.lineTo(x, y);
        }
        altCtx.stroke();

        // Current position dot
        const curX = aw - 1;
        const curAltY = ah - (Math.max(0, camY) / ALT_MAX) * ah;
        altCtx.fillStyle = 'rgba(255,220,150,0.9)';
        altCtx.beginPath();
        altCtx.arc(curX, curAltY, 3, 0, Math.PI * 2);
        altCtx.fill();
    }
}

requestAnimationFrame(frame);
</script>
</body>
</html>
