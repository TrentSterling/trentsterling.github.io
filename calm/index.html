<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (GA4) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-27SVZGYHZ3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-27SVZGYHZ3');
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>calm — tront.xyz</title>
<meta name="description" content="A quiet place to breathe. Meditative raymarched shader landscape.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://tront.xyz/calm/">
<meta property="og:title" content="calm — tront.xyz">
<meta property="og:description" content="A quiet place to breathe.">
<meta name="twitter:card" content="summary">
<link rel="icon" href="/favicon.png" type="image/png">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f}
canvas{display:block;width:100%;height:100%;position:fixed;top:0;left:0}

#overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}

#title{
  position:absolute;bottom:2.5rem;left:50%;transform:translateX(-50%);
  font-family:'Courier New',monospace;font-size:0.9rem;letter-spacing:0.4em;
  color:rgba(220,215,200,0.3);text-transform:uppercase;
  transition:opacity 1.5s ease;pointer-events:none;user-select:none;
  text-shadow:0 0 12px rgba(0,0,0,0.5);
}

#audio-hint{
  position:absolute;bottom:50%;left:50%;transform:translate(-50%,50%);
  font-family:'Courier New',monospace;font-size:0.85rem;letter-spacing:0.2em;
  color:rgba(180,170,160,0.0);text-transform:uppercase;
  transition:opacity 3s ease;pointer-events:none;user-select:none;
}
#audio-hint.visible{color:rgba(180,170,160,0.2)}
#audio-hint.fade{color:rgba(180,170,160,0.0)}

#controls{
  position:absolute;bottom:1.5rem;right:1.5rem;
  display:flex;flex-direction:column;gap:0.6rem;align-items:flex-end;
  opacity:0;transition:opacity 0.8s ease;pointer-events:auto;
}
#overlay:hover #controls,#controls:focus-within{opacity:1}

#controls label{
  font-family:'Courier New',monospace;font-size:0.85rem;
  color:rgba(230,225,215,0.85);letter-spacing:0.1em;
  display:flex;align-items:center;gap:0.6rem;
  text-shadow:0 1px 4px rgba(0,0,0,0.8);
}
#controls input[type=range]{
  width:120px;height:4px;-webkit-appearance:none;appearance:none;
  background:rgba(180,170,160,0.2);border-radius:2px;outline:none;
  cursor:pointer;
}
#controls input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;width:14px;height:14px;border-radius:50%;
  background:rgba(220,215,200,0.6);cursor:pointer;
}
#controls input[type=text]{
  width:110px;height:26px;background:rgba(0,0,0,0.5);
  border:1px solid rgba(255,255,255,0.15);border-radius:4px;
  color:rgba(230,225,215,0.85);font-family:'Courier New',monospace;
  font-size:0.85rem;padding:0 8px;outline:none;
}
#controls button{
  background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.15);
  border-radius:4px;color:rgba(230,225,215,0.85);
  font-family:'Courier New',monospace;font-size:0.85rem;
  padding:4px 14px;cursor:pointer;
}
#controls button:hover{background:rgba(0,0,0,0.65);border-color:rgba(255,255,255,0.25)}

#audio-btn{
  position:absolute;bottom:1.5rem;left:1.5rem;
  background:rgba(0,0,0,0.3);border:1px solid rgba(180,170,160,0.2);
  border-radius:50%;width:44px;height:44px;
  display:flex;align-items:center;justify-content:center;
  cursor:pointer;opacity:0;transition:opacity 0.8s ease;
  pointer-events:auto;
}
#overlay:hover #audio-btn{opacity:1}
#audio-btn svg{width:20px;height:20px;fill:rgba(220,215,200,0.5)}

/* HUD */
#hud{
  position:absolute;top:0;left:0;width:100%;height:100%;
  pointer-events:none;font-family:'Courier New',monospace;
  font-size:0.85rem;color:rgba(230,225,215,0.9);
  letter-spacing:0.06em;line-height:1.8;
  text-shadow:0 1px 4px rgba(0,0,0,0.8),0 0 12px rgba(0,0,0,0.5);
}
.hud-panel{
  background:rgba(0,0,0,0.45);backdrop-filter:blur(8px);
  -webkit-backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,0.08);border-radius:8px;
  padding:0.6rem 0.9rem;
}
#hud-tl{position:absolute;top:1rem;left:1.2rem}
#hud-tr{position:absolute;top:1rem;right:1.2rem;text-align:right}
#hud-bl{position:absolute;bottom:4rem;left:1.2rem}

/* Breathing bar */
#breath-bar{
  width:160px;height:5px;background:rgba(180,170,160,0.1);
  border-radius:3px;margin-top:6px;overflow:hidden;
}
#breath-fill{
  height:100%;width:50%;background:rgba(200,190,180,0.35);
  border-radius:3px;transition:width 0.1s linear;
}

/* Controls help */
#controls-help{
  position:absolute;bottom:50%;left:50%;transform:translate(-50%,50%);
  text-align:center;font-family:'Courier New',monospace;
  font-size:0.95rem;color:rgba(220,215,200,0.0);
  letter-spacing:0.12em;line-height:2.2;
  transition:color 2s ease,background 2s ease,border-color 2s ease;
  pointer-events:none;padding:1.2rem 2rem;border-radius:10px;
  background:rgba(0,0,0,0);border:1px solid rgba(255,255,255,0);
  text-shadow:0 1px 4px rgba(0,0,0,0.8);
}
#controls-help.visible{
  color:rgba(230,225,215,0.9);
  background:rgba(0,0,0,0.5);
  border-color:rgba(255,255,255,0.1);
}
#controls-help.fade{
  color:rgba(220,215,200,0.0);
  background:rgba(0,0,0,0);
  border-color:rgba(255,255,255,0);
}

/* Crosshair */
#crosshair{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  width:16px;height:16px;opacity:0;transition:opacity 0.3s;
}
#crosshair.active{opacity:1}
#crosshair::before,#crosshair::after{
  content:'';position:absolute;background:rgba(220,215,200,0.3);
}
#crosshair::before{width:1px;height:100%;left:50%;transform:translateX(-50%)}
#crosshair::after{width:100%;height:1px;top:50%;transform:translateY(-50%)}

/* Ambient clock */
#ambient-clock{
  position:absolute;top:50%;right:2.5rem;transform:translateY(-50%);
  font-family:'Courier New',monospace;font-size:2.8rem;
  color:rgba(180,170,160,0.0);letter-spacing:0.2em;
  transition:color 8s ease;pointer-events:none;user-select:none;
  text-shadow:0 0 30px rgba(180,170,160,0.15);font-weight:100;
}
#ambient-clock.visible{color:rgba(180,170,160,0.15)}

/* Quote */
#quote{
  position:absolute;bottom:6rem;left:50%;transform:translateX(-50%);
  font-family:'Courier New',monospace;font-size:0.95rem;
  color:rgba(180,170,160,0.0);letter-spacing:0.12em;
  text-align:center;max-width:600px;line-height:1.9;
  transition:color 4s ease;pointer-events:none;user-select:none;
  text-shadow:0 2px 6px rgba(0,0,0,0.6);font-style:italic;
}
#quote.visible{color:rgba(220,215,200,0.4)}

/* Pomodoro */
#pomodoro{
  position:absolute;bottom:4rem;right:1.5rem;text-align:right;
  pointer-events:auto;
}
#pomo-display{
  font-family:'Courier New',monospace;font-size:1.6rem;
  color:rgba(230,225,215,0.8);letter-spacing:0.12em;
  text-shadow:0 1px 4px rgba(0,0,0,0.8);
}
#pomo-label{
  font-family:'Courier New',monospace;font-size:0.75rem;
  color:rgba(200,195,185,0.5);letter-spacing:0.18em;
  text-transform:uppercase;margin-bottom:3px;
}
#pomo-bar{
  width:140px;height:4px;background:rgba(180,170,160,0.1);
  border-radius:2px;margin-top:6px;overflow:hidden;
}
#pomo-fill{
  height:100%;width:0%;border-radius:2px;
  transition:width 1s linear,background 0.5s;
}
#pomo-btn{
  background:rgba(0,0,0,0.4);border:1px solid rgba(180,170,160,0.2);
  border-radius:4px;color:rgba(230,225,215,0.6);
  font-family:'Courier New',monospace;font-size:0.8rem;
  padding:4px 14px;cursor:pointer;margin-top:6px;
  letter-spacing:0.12em;
}
#pomo-btn:hover{border-color:rgba(180,170,160,0.4);color:rgba(230,225,215,0.8)}

/* Altitude graph */
#alt-graph{
  position:absolute;bottom:4rem;left:50%;transform:translateX(-50%);
  pointer-events:none;
}
#alt-graph canvas{
  width:200px;height:50px;
  border:1px solid rgba(255,255,255,0.08);border-radius:4px;
  background:rgba(0,0,0,0.35);backdrop-filter:blur(4px);
}
#alt-label{
  font-family:'Courier New',monospace;font-size:0.65rem;
  color:rgba(200,195,185,0.5);text-align:center;letter-spacing:0.1em;
  margin-top:2px;
}

/* Loading screen */
#loading{
  position:fixed;top:0;left:0;width:100%;height:100%;
  background:#0a0a0f;z-index:9999;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  transition:opacity 1.5s ease;
}
#loading.done{opacity:0;pointer-events:none}
#load-title{
  font-family:'Courier New',monospace;font-size:1.2rem;
  color:rgba(200,195,185,0.7);letter-spacing:0.5em;text-transform:uppercase;
  margin-bottom:2rem;
}
#load-status{
  font-family:'Courier New',monospace;font-size:0.75rem;
  color:rgba(180,170,160,0.5);letter-spacing:0.15em;
  margin-bottom:1.5rem;
}
#load-bar-outer{
  width:200px;height:3px;background:rgba(180,170,160,0.1);
  border-radius:2px;overflow:hidden;
}
#load-bar-inner{
  height:100%;width:0%;background:rgba(200,195,185,0.4);
  border-radius:2px;transition:width 0.3s ease;
}
</style>
</head>
<body>
<div id="loading">
  <div id="load-title">calm</div>
  <div id="load-status">preparing...</div>
  <div id="load-bar-outer"><div id="load-bar-inner"></div></div>
</div>
<canvas id="c"></canvas>
<div id="overlay">
  <div id="hud">
    <div id="hud-tl" class="hud-panel">
      <div id="hud-fps">-- fps</div>
      <div id="hud-res">----</div>
      <div id="hud-seed">seed: --</div>
      <div id="hud-dpr">dpr: --</div>
    </div>
    <div id="hud-tr" class="hud-panel">
      <div id="hud-pos">pos: 0, 0, 0</div>
      <div id="hud-yaw">yaw: 0 pitch: 0</div>
      <div id="hud-time">time: 0.0s</div>
      <div id="hud-mode">mode: drift</div>
      <div id="hud-speed">speed: 1.0x</div>
    </div>
    <div id="hud-bl" class="hud-panel">
      <div>breath</div>
      <div id="breath-bar"><div id="breath-fill"></div></div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="title">calm</div>
  <div id="controls-help">
    wasd — move &nbsp; space/shift — up/down<br>
    mouse — look &nbsp; scroll — speed<br>
    click — lock cursor &nbsp; esc — unlock
  </div>
  <button id="audio-btn" title="Toggle audio">
    <svg id="audio-icon-on" viewBox="0 0 24 24" style="display:none"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    <svg id="audio-icon-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
  </button>
  <div id="ambient-clock"></div>
  <div id="quote"></div>
  <div id="pomodoro" class="hud-panel">
    <div id="pomo-label">focus</div>
    <div id="pomo-display">25:00</div>
    <div id="pomo-bar"><div id="pomo-fill"></div></div>
    <button id="pomo-btn">start</button>
  </div>
  <div id="alt-graph">
    <canvas id="alt-canvas" width="200" height="50"></canvas>
    <div id="alt-label">altitude</div>
  </div>
  <div id="controls">
    <label>seed <input type="text" id="seed-input" placeholder="random"></label>
    <label>speed <input type="range" id="speed" min="0" max="100" value="30"></label>
    <label>volume <input type="range" id="volume" min="0" max="100" value="50"></label>
    <button id="fs-btn">fullscreen</button>
  </div>
</div>

<!-- ======== VERTEX SHADER ======== -->
<script id="vs" type="x-shader/x-vertex">
attribute vec2 a_pos;
void main(){gl_Position=vec4(a_pos,0.0,1.0);}
</script>

<!-- ======== FRAGMENT SHADER ======== -->
<script id="fs" type="x-shader/x-fragment">
precision highp float;
uniform vec2 u_res;
uniform float u_time;
uniform float u_speed;
uniform vec3 u_camPos;
uniform vec3 u_camFwd;
uniform vec3 u_camRight;
uniform vec3 u_camUp;
uniform float u_breath;
uniform float u_seed;
uniform float u_transition;
uniform float u_prevSeed;
uniform float u_mobile;
uniform float u_velocity; // camera speed magnitude for speed lines

// --- Hash functions ---
float hash21(vec2 p){
    p=fract(p*vec2(443.897,397.297));
    p+=dot(p,p+19.19);
    return fract(p.x*p.y);
}
float hash31(vec3 p){
    p=fract(p*vec3(443.897,397.297,491.187));
    p+=dot(p,p.yzx+19.19);
    return fract((p.x+p.y)*p.z);
}

// --- Value noise ---
float vnoise(vec3 p){
    vec3 i=floor(p);
    vec3 f=fract(p);
    f=f*f*(3.0-2.0*f);
    float a=hash31(i);
    float b=hash31(i+vec3(1,0,0));
    float c=hash31(i+vec3(0,1,0));
    float d=hash31(i+vec3(1,1,0));
    float e=hash31(i+vec3(0,0,1));
    float g=hash31(i+vec3(1,0,1));
    float h=hash31(i+vec3(0,1,1));
    float k=hash31(i+vec3(1,1,1));
    return mix(mix(mix(a,b,f.x),mix(c,d,f.x),f.y),
               mix(mix(e,g,f.x),mix(h,k,f.x),f.y),f.z);
}

// --- FBM ---
float fbm(vec3 p, float oct){
    float v=0.0, a=0.5;
    for(float i=0.0;i<6.0;i+=1.0){
        if(i>=oct) break;
        v+=a*vnoise(p);
        p=p*2.03+vec3(1.7,1.2,2.8);
        a*=0.5;
    }
    return v;
}

// --- IQ Cosine palette (boosted saturation) ---
vec3 pal(float t, float sd){
    float s=sd*6.283;
    vec3 a=vec3(0.55,0.5,0.55);
    vec3 b=vec3(0.45,0.4,0.45);
    vec3 c=vec3(0.8+sin(s)*0.3, 1.0, 0.9+cos(s)*0.2);
    vec3 d=vec3(0.1+sin(s*2.0)*0.15, 0.25, 0.35+cos(s*1.3)*0.2);
    return a+b*cos(6.2832*(c*t+d));
}
// Shifted palette for variety
vec3 pal2(float t, float sd){
    return pal(t+0.33,sd+0.17);
}
vec3 pal3(float t, float sd){
    return pal(t+0.67,sd+0.41);
}

// --- SDF ---
float sdSphere(vec3 p,float r){return length(p)-r;}
float sdRBox(vec3 p,vec3 b,float r){
    vec3 q=abs(p)-b;
    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0)-r;
}
float sdCylinder(vec3 p,float r,float h){
    vec2 d=abs(vec2(length(p.xz),p.y))-vec2(r,h);
    return min(max(d.x,d.y),0.0)+length(max(d,0.0));
}
float sdTorus(vec3 p,float R,float r){
    vec2 q=vec2(length(p.xz)-R,p.y);
    return length(q)-r;
}
float smin(float a,float b,float k){
    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);
    return mix(b,a,h)-k*h*(1.0-h);
}

// --- Terrain height at xz ---
float terrainH(vec2 xz, float sd, float oct){
    float t=u_time*u_speed;
    vec3 tp=vec3(xz*0.12,0.0)+vec3(sd*13.7,sd*7.3,0.0);
    tp.xy+=t*0.02;
    float h=fbm(tp, oct)*3.0;
    h+=sin(xz.x*0.06+t*0.08)*cos(xz.y*0.05+t*0.06)*1.0;
    return h;
}

// --- Scene distance with material ID ---
// Returns vec2(distance, materialID)
// mat 0=ground, 1=sphere, 2=cube, 3=structure, 4=crystal, 5=cairn
vec2 mapMat(vec3 p, float sd, float oct){
    float t=u_time*u_speed;
    float breath=u_breath;
    float mat=0.0;

    // Ground
    float h=terrainH(p.xz, sd, oct);
    float ground=p.y-h;
    float d=ground;

    // Breathing spheres
    float spheres=1e5;
    float cellSp=40.0;
    vec3 spCell=floor(p/cellSp);
    vec3 spLocal=p-spCell*cellSp-cellSp*0.5;
    float spHash=hash31(spCell+sd*31.0);
    if(spHash<0.4){
        float sx=(spHash*2.0-1.0)*10.0+sin(t*0.04+spHash*6.0)*3.0;
        float sz=(fract(spHash*7.7)*2.0-1.0)*10.0+cos(t*0.03+spHash*4.0)*3.0;
        float r=1.0+spHash*0.8+breath*0.3;
        float sy=terrainH(spCell.xz*cellSp+vec2(sx,sz),sd,2.0)+r+1.0+breath*0.6;
        vec3 sCenter=vec3(sx,sy-spCell.y*cellSp-cellSp*0.5,sz);
        spheres=sdSphere(spLocal-sCenter,r);
    }
    if(spheres<d){ mat=1.0; }
    d=smin(d,spheres,3.0);

    // Voxel cubes
    float cubes=1e5;
    float cs=5.0;
    vec3 cid=floor(p/cs);
    vec3 cp2=mod(p,cs)-cs*0.5;
    float ch=hash31(cid+sd*47.0);
    if(ch<0.2 && cid.y<1.0){
        float fade=sin(t*0.06+ch*6.28)*0.5+0.5;
        fade=smoothstep(0.1,0.9,fade);
        float sz=0.3+ch*0.4;
        sz*=fade;
        sz+=breath*0.05;
        float rot=ch*6.28+t*0.02;
        float cr=cos(rot),sr=sin(rot);
        vec2 rp=mat2(cr,sr,-sr,cr)*cp2.xz;
        vec3 rcp=vec3(rp.x,cp2.y-sz-terrainH(cid.xz*cs,sd,2.0),rp.y);
        cubes=sdRBox(rcp,vec3(sz),0.1);
    }
    if(cubes<d){ mat=2.0; }
    d=smin(d,cubes,0.8);

    // Crystal clusters — medium grid, tall sharp shapes
    float crystals=1e5;
    float crCell=30.0;
    vec3 crId=floor(p/crCell);
    vec3 crLocal=p-crId*crCell-crCell*0.5;
    float crh=hash31(crId+sd*59.0);
    if(crh<0.15){
        float cx=(crh*2.0-1.0)*8.0;
        float cz=(fract(crh*11.0)*2.0-1.0)*8.0;
        float gH=hash21(crId.xz+sd*3.0)*3.0;
        vec3 cBase=vec3(cx,gH-crId.y*crCell-crCell*0.5,cz);
        // 3 crystals in a cluster
        for(float ci=0.0;ci<3.0;ci+=1.0){
            float ca=ci*2.09+crh*6.28;
            float coff=1.0+fract(crh*17.0+ci*3.3)*1.5;
            vec3 cpos=cBase+vec3(cos(ca)*coff,0.0,sin(ca)*coff);
            float cH=2.5+fract(crh*7.0+ci*2.1)*4.0+breath*0.3;
            float cR=0.3+fract(crh*3.0+ci)*0.4;
            // Tapered cylinder (crystal shape)
            vec3 lp=crLocal-cpos;
            lp.y-=cH;
            float taper=1.0-clamp(lp.y/(cH*2.0)+0.5,0.0,1.0)*0.7;
            float crDist=sdCylinder(lp,cR*taper,cH)-0.05;
            // Point on top
            crDist=smin(crDist,sdSphere(crLocal-cpos-vec3(0.0,cH*2.0+0.3,0.0),cR*0.5),0.3);
            crystals=min(crystals,crDist);
        }
    }
    if(crystals<d){ mat=4.0; }
    d=smin(d,crystals,0.5);

    // Cairns — stacked rounded stones
    float cairns=1e5;
    float cairnCell=55.0;
    vec3 cairnId=floor(p/cairnCell);
    vec3 cairnLocal=p-cairnId*cairnCell-cairnCell*0.5;
    float cairnH=hash31(cairnId+sd*83.0);
    if(cairnH<0.12){
        float bx=(cairnH*2.0-1.0)*15.0;
        float bz=(fract(cairnH*9.0)*2.0-1.0)*15.0;
        float gH2=hash21(cairnId.xz+sd*5.0)*3.0;
        vec3 cBase2=vec3(bx,gH2-cairnId.y*cairnCell-cairnCell*0.5,bz);
        float stackY=0.0;
        // 3-5 stacked stones
        float numStones=3.0+floor(fract(cairnH*23.0)*3.0);
        for(float si=0.0;si<5.0;si+=1.0){
            if(si>=numStones) break;
            float sr2=1.2-si*0.2+breath*0.05;
            float wobble=sin(t*0.015+si*1.5+cairnH*5.0)*0.15;
            vec3 stonePos=cBase2+vec3(wobble,stackY+sr2,wobble*0.5);
            cairns=smin(cairns,sdSphere(cairnLocal-stonePos,sr2),0.4);
            stackY+=sr2*1.6;
        }
    }
    if(cairns<d){ mat=5.0; }
    d=smin(d,cairns,0.8);

    // Large structures — monoliths, arches, rings
    float structs=1e5;
    float bigCell=120.0;
    vec3 bCell=floor(p/bigCell);
    vec3 bLocal=p-bCell*bigCell-bigCell*0.5;
    float bh=hash31(bCell+sd*73.0);
    float bh2=fract(bh*13.37);
    if(bh<0.25){
        float bx=(bh*2.0-1.0)*30.0;
        float bz=(bh2*2.0-1.0)*30.0;
        float groundH2=hash21(bCell.xz+sd*7.0)*3.0;
        vec3 base=vec3(bx,groundH2-bCell.y*bigCell-bigCell*0.5,bz);
        float kind=fract(bh*99.0);
        if(kind<0.35){
            float pillarH=6.0+bh2*8.0+breath*0.5;
            float pillarR=1.2+bh*1.5;
            vec3 pp=bLocal-base-vec3(0.0,pillarH,0.0);
            structs=sdCylinder(pp,pillarR,pillarH)-0.3;
            structs=smin(structs,sdSphere(bLocal-base-vec3(0.0,pillarH*2.0+0.5,0.0),pillarR*1.3+breath*0.3),1.5);
        } else if(kind<0.65){
            float archH=5.0+bh2*6.0;
            float archW=3.0+bh*3.0;
            float archR=0.8+bh2*0.5;
            vec3 lp=bLocal-base;
            float left=sdCylinder(lp-vec3(-archW,archH,0.0),archR,archH)-0.2;
            float right=sdCylinder(lp-vec3(archW,archH,0.0),archR,archH)-0.2;
            vec3 tp2=lp-vec3(0.0,archH*2.0,0.0);
            float archTop=sdTorus(tp2,archW,archR*1.2);
            archTop=max(archTop,-tp2.y);
            structs=min(left,right);
            structs=smin(structs,archTop,1.0);
        } else {
            float ringH=4.0+bh2*5.0+sin(t*0.02+bh*8.0)*1.5;
            float ringR=3.0+bh*4.0;
            float ringr=0.4+bh2*0.4+breath*0.15;
            vec3 rp2=bLocal-base-vec3(0.0,ringH,0.0);
            float tiltA=0.3+sin(t*0.008+bh2*5.0)*0.2;
            float tc=cos(tiltA),ts=sin(tiltA);
            vec3 rp3=vec3(rp2.x,rp2.y*tc-rp2.z*ts,rp2.y*ts+rp2.z*tc);
            structs=sdTorus(rp3,ringR,ringr);
        }
    }
    if(structs<d){ mat=3.0; }
    d=smin(d,structs,1.5);

    return vec2(d, mat);
}

// Distance-only version for normals/AO (cheaper)
float mapDist(vec3 p, float sd, float oct){
    return mapMat(p,sd,oct).x;
}

vec3 calcN(vec3 p, float sd, float oct){
    vec2 e=vec2(0.025,0.0);
    return normalize(vec3(
        mapDist(p+e.xyy,sd,oct)-mapDist(p-e.xyy,sd,oct),
        mapDist(p+e.yxy,sd,oct)-mapDist(p-e.yxy,sd,oct),
        mapDist(p+e.yyx,sd,oct)-mapDist(p-e.yyx,sd,oct)
    ));
}

float ao(vec3 p, vec3 n, float sd, float oct){
    float o=0.0,s=1.0;
    for(float i=0.0;i<4.0;i+=1.0){
        float h=0.03+0.15*i;
        float dd=mapDist(p+n*h,sd,oct);
        o+=(h-dd)*s;
        s*=0.65;
    }
    return clamp(1.0-2.0*o,0.0,1.0);
}

// --- Sky color with distinct atmosphere layers ---
vec3 skyColor(vec3 rd, float sd, float time){
    float camH=u_camPos.y;

    // Layer weights — smooth transitions between 6 altitude bands
    float wGround   = 1.0-smoothstep(0.0,20.0,camH);     // 0-20: ground haze
    float wLowCloud = smoothstep(8.0,18.0,camH)*(1.0-smoothstep(18.0,35.0,camH)); // 8-35: cloud layer
    float wHighSky  = smoothstep(20.0,45.0,camH)*(1.0-smoothstep(45.0,70.0,camH)); // 20-70: clear blue
    float wStrato   = smoothstep(50.0,75.0,camH)*(1.0-smoothstep(75.0,105.0,camH)); // 50-105: stratosphere violet
    float wMeso     = smoothstep(85.0,110.0,camH)*(1.0-smoothstep(110.0,135.0,camH)); // 85-135: mesosphere dark
    float wSpace    = smoothstep(115.0,145.0,camH); // 115+: space

    // Each layer has its own sky gradient
    // Ground: warm haze, amber horizon
    vec3 skyGround;
    {
        vec3 hi=pal(0.65,sd)*0.55+vec3(0.04,0.05,0.12);
        vec3 lo=pal2(0.2,sd)*0.65+vec3(0.14,0.08,0.04);
        skyGround=mix(lo,hi,clamp(rd.y*0.5+0.5,0.0,1.0));
        skyGround+=pal3(0.3,sd)*0.3*exp(-6.0*rd.y*rd.y); // warm horizon band
    }

    // Cloud layer: brighter, whiter, hazier
    vec3 skyCloud;
    {
        vec3 hi=vec3(0.45,0.5,0.6)+pal(0.5,sd)*0.2;
        vec3 lo=vec3(0.55,0.52,0.5)+pal2(0.3,sd)*0.15;
        skyCloud=mix(lo,hi,clamp(rd.y*0.6+0.4,0.0,1.0));
        // Volumetric haze feel — whiter, less saturated
        float haze=exp(-3.0*abs(rd.y));
        skyCloud=mix(skyCloud,vec3(0.6,0.58,0.55),haze*0.5);
    }

    // High sky: clear deep blue, sharper contrast
    vec3 skyHigh;
    {
        vec3 hi=pal(0.7,sd)*0.5+vec3(0.02,0.04,0.2);
        vec3 lo=pal2(0.45,sd)*0.4+vec3(0.08,0.06,0.08);
        skyHigh=mix(lo,hi,clamp(rd.y*0.5+0.5,0.0,1.0));
    }

    // Stratosphere: violet/purple tones, thin air
    vec3 skyStrato;
    {
        vec3 hi=vec3(0.08,0.04,0.2)+pal(0.8,sd)*0.15;
        vec3 lo=vec3(0.15,0.08,0.18)+pal3(0.6,sd)*0.12;
        skyStrato=mix(lo,hi,clamp(rd.y*0.5+0.5,0.0,1.0));
        // Faint glow at horizon — last traces of atmosphere
        skyStrato+=vec3(0.12,0.08,0.2)*exp(-4.0*rd.y*rd.y);
    }

    // Mesosphere: near-black with hints of deep blue
    vec3 skyMeso;
    {
        skyMeso=vec3(0.015,0.012,0.04)+pal(0.75,sd)*0.03;
        // Aurora-like shimmer at horizon
        float aur=exp(-6.0*rd.y*rd.y)*vnoise(vec3(rd.xz*8.0,time*0.02+sd));
        vec3 aurCol=pal2(aur+time*0.005,sd)*0.08;
        skyMeso+=aurCol*smoothstep(0.2,0.5,aur);
    }

    // Space: black with nebula
    vec3 skySpace;
    {
        skySpace=vec3(0.004,0.003,0.012);
        float nebula=vnoise(vec3(rd.xy*3.0+sd*5.0,rd.z*3.0))*0.5+
                     vnoise(vec3(rd.xz*6.0+sd*11.0,rd.y*6.0))*0.3;
        nebula=smoothstep(0.3,0.7,nebula);
        vec3 nebulaCol=pal2(nebula*0.6+0.2,sd)*0.08;
        skySpace+=nebulaCol*wSpace;
    }

    // Blend all layers by weight
    vec3 sky=skyGround*wGround
            +skyCloud*wLowCloud
            +skyHigh*wHighSky
            +skyStrato*wStrato
            +skyMeso*wMeso
            +skySpace*wSpace;
    // Normalize when between bands (weights don't always sum to 1)
    float wSum=wGround+wLowCloud+wHighSky+wStrato+wMeso+wSpace;
    if(wSum>0.01) sky/=wSum;

    // Atmosphere rim — looking sideways/down from high altitude
    if(camH>40.0){
        float rimStrength=smoothstep(40.0,100.0,camH);
        float horizonGlow=exp(-6.0*rd.y*rd.y)*rimStrength;
        // Multi-color rim: blue-white core + orange fringe
        vec3 rimCore=vec3(0.35,0.5,0.85)+pal2(0.3,sd)*0.3;
        vec3 rimFringe=vec3(0.25,0.15,0.05)+pal(0.15,sd)*0.2;
        float rimBand=exp(-20.0*(rd.y-0.05)*(rd.y-0.05));
        sky+=rimCore*horizonGlow*0.5;
        sky+=rimFringe*rimBand*rimStrength*0.3;

        // Planet glow when looking down from high up
        float downGlow=max(-rd.y,0.0)*smoothstep(70.0,140.0,camH);
        vec3 planetGlow=pal(0.2,sd)*0.25+vec3(0.04,0.06,0.03);
        sky=mix(sky,planetGlow,downGlow*0.5);
    }

    // Sun disc + halo
    vec3 sunDir=normalize(vec3(sin(time*0.02)*0.4,0.3,cos(time*0.02)*0.4));
    float sun=pow(max(dot(rd,sunDir),0.0),80.0);
    float sunGlow=pow(max(dot(rd,sunDir),0.0),8.0);
    float sunBright=mix(2.5,6.0,wSpace);
    sky+=pal(0.15,sd)*sun*sunBright;
    sky+=pal2(0.1,sd)*sunGlow*mix(0.15,0.03,wSpace);

    // Stars — progressively visible from stratosphere up
    float starVis0=wStrato+wMeso+wSpace; // stars start in stratosphere
    float star=hash31(floor(rd*300.0));
    float starThresh=mix(0.999,0.99,starVis0);
    float starOn=step(starThresh,star);
    float starMask=mix(smoothstep(0.0,0.3,rd.y),1.0,smoothstep(0.3,1.0,starVis0));
    float starBright=mix(0.3,1.5,starVis0);
    float twinkle=sin(time*0.5+star*100.0)*0.3+0.7;
    sky+=starOn*starMask*starBright*twinkle;

    // Dense star field in deep space + mesosphere
    if(starVis0>0.15){
        float star2=hash31(floor(rd*800.0)+vec3(77.0));
        float starVis2=step(0.993,star2)*starVis0;
        float twinkle2=sin(time*0.3+star2*50.0)*0.2+0.8;
        sky+=starVis2*0.35*twinkle2*vec3(0.8,0.85,1.0);
        // Third layer: very faint tiny stars
        float star3=hash31(floor(rd*1500.0)+vec3(133.0));
        float starVis3=step(0.996,star3)*wSpace;
        sky+=starVis3*0.15*vec3(0.9,0.9,1.0);
    }

    return sky;
}

// --- Single cloud plane renderer ---
vec3 renderCloudPlane(vec3 ro, vec3 rd, float sd, vec3 sky, float time, float cloudH, float scale, float opacity, vec3 tint, float fadeAbove){
    if(abs(rd.y)<0.001) return sky;
    float tCloud=(cloudH-ro.y)/rd.y;
    if(tCloud<0.0||tCloud>400.0) return sky;
    float cloudAlpha=1.0-smoothstep(fadeAbove,fadeAbove+80.0,ro.y);
    if(cloudAlpha<0.01) return sky;

    vec3 cp=ro+rd*tCloud;
    vec2 uv2=cp.xz*scale+time*0.005;
    float n1=vnoise(vec3(uv2*3.0,time*0.01+sd*10.0));
    float n2=vnoise(vec3(uv2*6.0+5.0,time*0.015+sd*5.0));
    float n3=vnoise(vec3(uv2*12.0+10.0,time*0.008));
    float density=n1*0.5+n2*0.3+n3*0.2;
    density=smoothstep(0.32,0.68,density);
    density*=exp(-0.003*tCloud); // fade at distance
    float clight=n1*0.3+0.7;
    vec3 cloudCol=tint*clight;

    return mix(sky,cloudCol,density*opacity*cloudAlpha);
}

// --- Multi-layer clouds ---
vec3 renderClouds(vec3 ro, vec3 rd, float sd, vec3 sky, float time){
    vec3 col=sky;
    // Layer 1: Low cumulus clouds at y=15 (warm, thick)
    vec3 tint1=pal(0.3,sd)*0.75+vec3(0.22,0.19,0.16);
    col=renderCloudPlane(ro,rd,sd,col,time, 15.0, 0.008, 0.65, tint1, 60.0);

    // Layer 2: Mid-altitude wisps at y=35 (cooler, thinner)
    vec3 tint2=pal2(0.5,sd)*0.5+vec3(0.3,0.3,0.35);
    col=renderCloudPlane(ro,rd,sd,col,time*1.3, 35.0, 0.005, 0.4, tint2, 90.0);

    // Layer 3: High cirrus at y=60 (icy, very thin, wide)
    vec3 tint3=vec3(0.35,0.38,0.5)+pal3(0.65,sd)*0.15;
    col=renderCloudPlane(ro,rd,sd,col,time*0.7, 60.0, 0.003, 0.25, tint3, 120.0);

    return col;
}

// --- Water plane at y=waterH ---
vec3 renderWater(vec3 ro, vec3 rd, float sd, float oct, float time, vec3 behindCol){
    float waterH=-0.5;
    // Only if ray hits water plane
    if(rd.y>-0.001) return behindCol;
    float tWater=(waterH-ro.y)/rd.y;
    if(tWater<0.0||tWater>100.0) return behindCol;

    vec3 wp=ro+rd*tWater;

    // Animated water normal from noise
    vec2 wuv=wp.xz;
    float t2=time;
    float wx=vnoise(vec3(wuv*0.3+t2*0.03,t2*0.02+sd))*2.0-1.0;
    float wz=vnoise(vec3(wuv*0.3+100.0+t2*0.025,t2*0.018+sd))*2.0-1.0;
    vec3 wn=normalize(vec3(wx*0.08,1.0,wz*0.08));

    // Reflect ray
    vec3 rrd=reflect(rd,wn);
    rrd.y=max(rrd.y,0.01);
    vec3 reflCol=skyColor(rrd,sd,time);
    // Add cloud reflection
    reflCol=renderClouds(wp,rrd,sd,reflCol,time);

    // Fresnel
    float fres=pow(1.0-max(dot(wn,-rd),0.0),4.0);
    fres=0.3+0.7*fres;

    // Water tint — more colorful
    vec3 waterTint=pal3(0.5,sd)*0.25+vec3(0.03,0.06,0.1);

    vec3 col=mix(waterTint,reflCol,fres);

    // Distance fog on water — blend to sky at horizon
    float wfog=1.0-exp(-0.00015*tWater*tWater);
    col=mix(col,behindCol,wfog);

    return col;
}

vec3 render(vec3 ro, vec3 rd, float sd, float oct, float maxSteps){
    float time=u_time*u_speed;

    // Sky + clouds
    vec3 sky=skyColor(rd,sd,time);
    sky=renderClouds(ro,rd,sd,sky,time);

    // Time-varying fog — shifts hue over time for variety
    float fogCycle=sin(time*0.008)*0.5+0.5; // slow 0-1 cycle
    vec3 fogWarm=pal(0.15+fogCycle*0.2,sd)*0.9+vec3(0.1,0.05,0.02);
    vec3 fogCool=pal2(0.6+fogCycle*0.15,sd)*0.6+vec3(0.02,0.04,0.1);
    vec3 fogCol=mix(fogWarm,fogCool,clamp(rd.y*0.5+0.5,0.0,1.0));
    // Blend in a third color at the horizon band
    vec3 fogMid=pal3(0.3+fogCycle*0.3,sd)*0.5+vec3(0.06,0.04,0.06);
    fogCol=mix(fogCol,fogMid,exp(-8.0*rd.y*rd.y));
    vec3 horizonCol=mix(fogCol,sky,0.45);

    // Raymarch
    float maxDist=120.0;
    float t=0.0;
    float matID=0.0;
    for(float i=0.0;i<100.0;i++){
        if(i>=maxSteps) break;
        vec3 p=ro+rd*t;
        vec2 dm=mapMat(p,sd,oct);
        if(dm.x<0.01*t){ matID=dm.y; break; }
        t+=dm.x*0.9;
        if(t>maxDist) break;
    }

    if(t>maxDist){
        vec3 miss=renderWater(ro,rd,sd,oct,time,sky);
        return miss;
    }

    vec3 p=ro+rd*t;
    vec3 n=calcN(p,sd,oct);

    // Two-tone lighting: main light + colored fill
    float sunAngle=time*0.025;
    vec3 ld=normalize(vec3(sin(sunAngle)*0.5,0.7,cos(sunAngle)*0.5));
    vec3 ld2=normalize(vec3(-cos(sunAngle)*0.3,0.2,sin(sunAngle)*0.3)); // fill from opposite side
    float diff=dot(n,ld)*0.5+0.5;
    diff*=diff;
    float diff2=dot(n,ld2)*0.5+0.5;
    float occ=ao(p,n,sd,oct);
    float fres=pow(1.0-max(dot(n,-rd),0.0),3.0);

    // Light colors shift over time
    vec3 sunCol=pal(0.15+fogCycle*0.15,sd)*1.3+vec3(0.2,0.15,0.1);
    vec3 fillCol=pal3(0.5+fogCycle*0.2,sd)*0.4+vec3(0.05,0.08,0.12);

    // Material color based on ID — more variation with position and time
    float nv=vnoise(p*0.15+sd*10.0);
    float nv2=vnoise(p*0.07+vec3(time*0.01)); // slow position-based color shift
    vec3 matCol;
    if(matID<0.5){
        // Ground — earthy with color pools
        matCol=pal(nv*0.5+0.15+nv2*0.15,sd)*1.2+vec3(0.05,0.03,0.0);
        // Color patches on ground
        matCol=mix(matCol,pal2(nv*0.4+0.3,sd)*1.0,smoothstep(0.4,0.6,nv2)*0.4);
    } else if(matID<1.5){
        // Breathing spheres — warm saturated, each slightly different
        float sphereHue=hash31(floor(p/40.0)+sd*31.0);
        matCol=pal2(nv*0.3+sphereHue*0.4+0.1,sd)*1.5+vec3(0.15,0.05,0.02);
    } else if(matID<2.5){
        // Cubes — cool tones, each cube unique
        float cubeHue=hash31(floor(p/5.0)+sd*47.0);
        matCol=pal3(cubeHue*0.6+nv*0.2+0.3,sd)*1.4+vec3(0.02,0.08,0.1);
    } else if(matID<3.5){
        // Large structures — warm stone with colored veins
        matCol=pal(nv*0.2+0.4,sd)*1.0+vec3(0.12,0.1,0.1);
        vec3 vein=pal2(nv*0.8+0.5,sd)*0.6;
        matCol=mix(matCol,vein,smoothstep(0.45,0.55,vnoise(p*0.4))*0.35);
    } else if(matID<4.5){
        // Crystals — vibrant gem-like, each cluster different
        float crystHue=hash31(floor(p/30.0)+sd*59.0);
        matCol=pal2(crystHue*0.5+nv*0.4+0.2,sd)*2.0+vec3(0.1,0.05,0.15);
    } else {
        // Cairns — warm stone, subtle variation
        float cairnHue=hash31(floor(p/55.0)+sd*83.0);
        matCol=pal3(cairnHue*0.3+nv*0.3+0.15,sd)*1.3+vec3(0.1,0.07,0.03);
    }

    // Compose with two-tone lighting
    vec3 col=vec3(0.0);
    col+=matCol*diff*occ*sunCol*1.5;
    col+=matCol*diff2*fillCol*0.5;
    col+=matCol*0.2;

    // Fresnel rim — tinted by opposite light for color contrast
    vec3 rimCol=mix(pal2(0.6,sd),pal3(0.4,sd),fogCycle);
    col+=rimCol*fres*0.7;

    // Specular on crystals
    if(matID>3.5 && matID<4.5){
        float spec=pow(max(dot(reflect(-ld,n),-rd),0.0),32.0);
        col+=pal2(0.5+fogCycle*0.2,sd)*spec*1.8;
    }

    // Specular glint on spheres too
    if(matID>0.5 && matID<1.5){
        float spec=pow(max(dot(reflect(-ld,n),-rd),0.0),16.0);
        col+=sunCol*spec*0.4;
    }

    // Distance fog — color shifts with depth
    float fog=1.0-exp(-0.00015*t*t);
    vec3 depthFog=mix(fogCol,horizonCol,smoothstep(20.0,80.0,t));
    col=mix(col,depthFog,fog);
    col=mix(col,sky,smoothstep(60.0,maxDist,t));

    return col;
}

void main(){
    float oct=u_mobile>0.5?3.0:5.0;
    float maxSteps=u_mobile>0.5?40.0:80.0;

    vec2 uv=(gl_FragCoord.xy-u_res*0.5)/u_res.y;

    // Camera from JS
    vec3 ro=u_camPos;
    vec3 rd=normalize(u_camFwd+uv.x*u_camRight+uv.y*u_camUp);

    vec3 col=render(ro,rd,u_seed,oct,maxSteps);

    if(u_transition>0.01){
        vec3 col2=render(ro,rd,u_prevSeed,oct,maxSteps);
        col=mix(col,col2,u_transition);
    }

    // Tonemap (gentle)
    col=col/(0.7+col);

    // Vignette (soft)
    vec2 vuv=gl_FragCoord.xy/u_res;
    float vig=vuv.x*vuv.y*(1.0-vuv.x)*(1.0-vuv.y);
    col*=mix(0.7,1.0,clamp(pow(vig*16.0,0.35),0.0,1.0));

    // Speed streaks — screen-space radial + subtle world-space dots
    float spdNorm=clamp(u_velocity/30.0, 0.0, 1.0);
    if(spdNorm>0.05){
        vec2 ctr=gl_FragCoord.xy/u_res-0.5;
        float dist=length(ctr);
        float angle=atan(ctr.y,ctr.x);
        // Radial streaks at edges
        float streak=hash21(vec2(floor(angle*80.0),floor(u_time*2.0+dist*4.0)));
        float radial=smoothstep(0.2,0.5,dist)*step(0.7,streak);
        col+=vec3(0.8,0.85,0.95)*radial*spdNorm*spdNorm*0.25;
    }

    // Grain
    col+=hash31(vec3(gl_FragCoord.xy,fract(u_time*71.0)))*0.025-0.0125;

    // Gamma
    col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2));

    gl_FragColor=vec4(col,1.0);
}
</script>

<script>
// Loading screen helpers
const loadBar = document.getElementById('load-bar-inner');
const loadStatus = document.getElementById('load-status');
const loadScreen = document.getElementById('loading');
function loadProgress(pct, msg) {
    loadBar.style.width = pct + '%';
    if (msg) loadStatus.textContent = msg;
}
function yieldFrame() { return new Promise(r => requestAnimationFrame(r)); }

// ============================================
// MULBERRY32 SEEDED PRNG (same as lofigen)
// ============================================
function mulberry32(seed) {
    if (typeof seed === 'string') {
        let h = 0;
        for (let i = 0; i < seed.length; i++) {
            h = ((h << 5) - h + seed.charCodeAt(i)) | 0;
        }
        seed = h >>> 0;
    }
    seed = seed >>> 0;
    return function() {
        seed |= 0;
        seed = (seed + 0x6D2B79F5) | 0;
        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function seedToFloat(s) {
    if (typeof s === 'number') return s;
    let h = 0;
    for (let i = 0; i < s.length; i++) {
        h = ((h << 5) - h + s.charCodeAt(i)) | 0;
    }
    return (h >>> 0) / 4294967296;
}

// ============================================
// DEBUG LOGGING
// ============================================
const dbg = (ok, msg) => console.log(`%c[${ok?'OK':'FAIL'}] ${msg}`, `color:${ok?'#4f4':'#f44'};font-weight:bold`);

// ============================================
// WEBGL SETUP — dual shader: instant placeholder + async main
// ============================================
const canvas = document.getElementById('c');
dbg(!!canvas, 'Canvas element found');

const gl = canvas.getContext('webgl', { antialias: false, alpha: false });
dbg(!!gl, 'WebGL context created');

// Check for parallel shader compile extension
const parallelCompile = gl.getExtension('KHR_parallel_shader_compile');
dbg(!!parallelCompile, `Parallel shader compile: ${parallelCompile ? 'yes' : 'no'}`);

loadProgress(5, 'webgl ready');

(async function init() {
await yieldFrame();

function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s; // don't check status yet — let GPU compile in background
}
function checkShader(s, label) {
    const ok = gl.getShaderParameter(s, gl.COMPILE_STATUS);
    dbg(ok, `${label} shader compiled`);
    if (!ok) console.error(gl.getShaderInfoLog(s));
    return ok;
}
function linkProg(v, f) {
    const p = gl.createProgram();
    gl.attachShader(p, v); gl.attachShader(p, f);
    gl.linkProgram(p);
    return p;
}

// ---- Step 1: Compile simple placeholder shader (instant) ----
const placeholderFS = `precision mediump float;
uniform vec2 u_res; uniform float u_time; uniform vec3 u_camPos;
void main(){
    vec2 uv=gl_FragCoord.xy/u_res;
    float t=u_time*0.15;
    vec3 lo=vec3(0.08+sin(t)*0.02, 0.06, 0.04+cos(t)*0.02);
    vec3 hi=vec3(0.04, 0.05+sin(t*0.7)*0.01, 0.12);
    vec3 col=mix(lo,hi,uv.y);
    col+=sin(uv.x*6.0+t*2.0)*0.01;
    float vig=uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);
    col*=mix(0.6,1.0,clamp(pow(vig*16.0,0.4),0.0,1.0));
    gl_FragColor=vec4(col,1.0);
}`;
const vsSrc = document.getElementById('vs').textContent;
const placeholderVS = compileShader(gl.VERTEX_SHADER, vsSrc);
const placeholderFSc = compileShader(gl.FRAGMENT_SHADER, placeholderFS);
// These are trivial — check immediately
checkShader(placeholderVS, 'Placeholder vertex');
checkShader(placeholderFSc, 'Placeholder fragment');
const placeholderProg = linkProg(placeholderVS, placeholderFSc);
gl.useProgram(placeholderProg);

// Setup geometry for placeholder
const plPos = gl.getAttribLocation(placeholderProg, 'a_pos');
const plBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, plBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(plPos);
gl.vertexAttribPointer(plPos, 2, gl.FLOAT, false, 0, 0);

const plRes = gl.getUniformLocation(placeholderProg, 'u_res');
const plTime = gl.getUniformLocation(placeholderProg, 'u_time');
const plCamPos = gl.getUniformLocation(placeholderProg, 'u_camPos');

loadProgress(10, 'rendering placeholder...');
// Render placeholder behind loading screen immediately
const plW = Math.floor(window.innerWidth * 0.5);
const plH = Math.floor(window.innerHeight * 0.5);
canvas.width = plW; canvas.height = plH;
gl.viewport(0, 0, plW, plH);
gl.uniform2f(plRes, plW, plH);
gl.uniform1f(plTime, 0);
gl.uniform3f(plCamPos, 0, 3.5, 0);
gl.drawArrays(gl.TRIANGLES, 0, 3);

// ---- Step 2: Kick off main shader compilation in background ----
loadProgress(15, 'compiling main shader...');
await yieldFrame();

const mainVS = compileShader(gl.VERTEX_SHADER, vsSrc);
const mainFS = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent);

// Animate placeholder while main shader compiles
const compileStart = performance.now();
const COMPILE_STATUS = parallelCompile ? parallelCompile.COMPLETION_STATUS_KHR : gl.COMPILE_STATUS;

async function waitForShader(s, label) {
    if (parallelCompile) {
        // Poll completion without blocking
        while (!gl.getShaderParameter(s, COMPILE_STATUS)) {
            const elapsed = ((performance.now() - compileStart) / 1000).toFixed(1);
            loadProgress(20 + Math.min(40, (performance.now() - compileStart) / 50), `compiling ${label}... ${elapsed}s`);
            // Render placeholder animation while waiting
            const t = (performance.now() - compileStart) / 1000;
            gl.useProgram(placeholderProg);
            gl.uniform1f(plTime, t);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            await yieldFrame();
        }
    } else {
        // No parallel compile — just yield a few frames and hope
        for (let i = 0; i < 3; i++) {
            const t = (performance.now() - compileStart) / 1000;
            gl.useProgram(placeholderProg);
            gl.uniform1f(plTime, t);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            await yieldFrame();
        }
    }
    return checkShader(s, label);
}

await waitForShader(mainVS, 'vertex');
await waitForShader(mainFS, 'fragment');

loadProgress(65, 'linking main program...');
await yieldFrame();

const prog = linkProg(mainVS, mainFS);
const linked = gl.getProgramParameter(prog, gl.LINK_STATUS);
dbg(linked, 'Main program linked');
if (!linked) console.error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);
dbg(true, `Shader compile took ${((performance.now() - compileStart)/1000).toFixed(1)}s`);

// Reuse fullscreen triangle buffer from placeholder
const aPos = gl.getAttribLocation(prog, 'a_pos');
gl.bindBuffer(gl.ARRAY_BUFFER, plBuf);
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uRes = gl.getUniformLocation(prog, 'u_res');
const uTime = gl.getUniformLocation(prog, 'u_time');
const uSpeed = gl.getUniformLocation(prog, 'u_speed');
const uCamPos = gl.getUniformLocation(prog, 'u_camPos');
const uCamFwd = gl.getUniformLocation(prog, 'u_camFwd');
const uCamRight = gl.getUniformLocation(prog, 'u_camRight');
const uCamUp = gl.getUniformLocation(prog, 'u_camUp');
const uBreath = gl.getUniformLocation(prog, 'u_breath');
const uSeed = gl.getUniformLocation(prog, 'u_seed');
const uTransition = gl.getUniformLocation(prog, 'u_transition');
const uPrevSeed = gl.getUniformLocation(prog, 'u_prevSeed');
const uMobile = gl.getUniformLocation(prog, 'u_mobile');
const uVelocity = gl.getUniformLocation(prog, 'u_velocity');

const uniforms = {uRes,uTime,uSpeed,uCamPos,uCamFwd,uCamRight,uCamUp,uBreath,uSeed,uTransition,uPrevSeed,uMobile};
const uniformNames = Object.keys(uniforms);
const allUniformsOk = uniformNames.every(n => uniforms[n] !== null);
dbg(allUniformsOk, `All ${uniformNames.length} uniforms located` + (allUniformsOk ? '' : ' — MISSING: ' + uniformNames.filter(n=>uniforms[n]===null).join(', ')));

loadProgress(60, 'setting up uniforms...');
await yieldFrame();

// ============================================
// STATE
// ============================================
let currentSeed = 'calm';
let currentSeedFloat = seedToFloat(currentSeed);
let prevSeedFloat = currentSeedFloat;
let transition = 0;
let speedMul = 0.3;
let dpr = Math.min((window.devicePixelRatio || 1) * 0.5, 1); // start at half res
const targetDpr = Math.min(window.devicePixelRatio || 1, 2);
let dprRampTimer = 0;
let isMobile = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
let audioStarted = false;
let audioCtx = null;
let masterGain = null;
let altAudioFade = 1.0; // altitude-based audio fade (1=full, 0=silent)
let droneGainNodes = []; // store drone gain nodes for altitude modulation
let rainGainNode = null; // store rain gain node for altitude modulation
let spaceHumGain = null; // space engine hum gain node

// Adaptive quality
let frameCount = 0;
let fpsAccum = 0;
let currentFps = 60;

// Camera state
let camX = 0, camY = 3.5, camZ = 0;
let camYaw = 0, camPitch = -0.15; // radians
let velX = 0, velY = 0, velZ = 0;
const moveSpeed = 8.0;
const mouseSens = 0.002;
const camDamping = 0.85;
let pointerLocked = false;
let flyMode = false; // true = WASD active, false = auto-drift
let idleTimer = 0;
const IDLE_TIMEOUT = 3.0; // seconds of no input before auto-drift resumes
let driftTime = 0; // accumulated drift time for altitude journey
let driftPhase = Math.random() * Math.PI * 2; // randomize starting phase

// Keyboard
const keys = {};
document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['KeyW','KeyA','KeyS','KeyD','Space','ShiftLeft','ShiftRight'].includes(e.code)) {
        flyMode = true;
        idleTimer = 0;
        e.preventDefault();
    }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Scroll wheel: adjust fly speed
let flySpeedMul = 5.0; // default to fast — feels better
document.addEventListener('wheel', e => {
    flySpeedMul *= e.deltaY < 0 ? 1.15 : 0.87;
    flySpeedMul = Math.max(0.1, Math.min(20.0, flySpeedMul));
    e.preventDefault();
}, { passive: false });

// ============================================
// SEED FROM URL HASH
// ============================================
function loadSeedFromHash() {
    const hash = window.location.hash.slice(1);
    if (hash) {
        currentSeed = decodeURIComponent(hash);
        currentSeedFloat = seedToFloat(currentSeed);
        prevSeedFloat = currentSeedFloat;
        document.getElementById('seed-input').value = currentSeed;
    } else {
        // Random seed on first load
        currentSeed = String(Math.floor(Math.random() * 99999));
        currentSeedFloat = seedToFloat(currentSeed);
        prevSeedFloat = currentSeedFloat;
    }
}
loadSeedFromHash();

window.addEventListener('hashchange', () => {
    const hash = window.location.hash.slice(1);
    if (hash) changeSeed(decodeURIComponent(hash));
});

function changeSeed(newSeed) {
    if (newSeed === currentSeed) return;
    prevSeedFloat = currentSeedFloat;
    currentSeed = newSeed;
    currentSeedFloat = seedToFloat(currentSeed);
    transition = 1.0;
    window.history.replaceState(null, '', '#' + encodeURIComponent(currentSeed));
}

// ============================================
// CONTROLS
// ============================================
const seedInput = document.getElementById('seed-input');
const speedSlider = document.getElementById('speed');
const volumeSlider = document.getElementById('volume');
const fsBtn = document.getElementById('fs-btn');
const audioBtn = document.getElementById('audio-btn');

seedInput.value = currentSeed;
seedInput.addEventListener('change', () => {
    const v = seedInput.value.trim();
    if (v) changeSeed(v);
});

speedSlider.addEventListener('input', () => {
    speedMul = speedSlider.value / 100;
});

volumeSlider.addEventListener('input', () => {
    if (masterGain) {
        masterGain.gain.setTargetAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime, 0.1);
    }
});

fsBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
    } else {
        document.exitFullscreen();
    }
});

audioBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleAudio();
});

// ============================================
// MOUSE / POINTER LOCK
// ============================================
document.addEventListener('mousemove', (e) => {
    if (pointerLocked) {
        camYaw += e.movementX * mouseSens;
        camPitch -= e.movementY * mouseSens;
        camPitch = Math.max(-1.4, Math.min(1.4, camPitch));
        if (Math.abs(e.movementX) + Math.abs(e.movementY) > 2) {
            idleTimer = 0;
            flyMode = true;
        }
    }
});

canvas.addEventListener('click', () => {
    if (!pointerLocked) {
        canvas.requestPointerLock();
    }
    if (!audioStarted) startAudio();
});

document.addEventListener('pointerlockchange', () => {
    pointerLocked = document.pointerLockElement === canvas;
    document.getElementById('crosshair').classList.toggle('active', pointerLocked);
});

// Mute when tab is hidden (minimized) — but keep playing on alt-tab (blur)
document.addEventListener('visibilitychange', () => {
    if (!audioCtx || !masterGain) return;
    if (document.hidden) {
        masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
        setTimeout(() => { if (document.hidden && audioCtx.state === 'running') audioCtx.suspend(); }, 500);
    } else {
        if (audioCtx.state === 'suspended' && audioStarted) {
            audioCtx.resume().then(() => {
                masterGain.gain.setTargetAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime, 0.5);
            });
        }
    }
});

document.addEventListener('touchmove', (e) => {
    const t = e.touches[0];
    camYaw = -((t.clientX / window.innerWidth) * 2 - 1) * 0.5;
    camPitch = -((t.clientY / window.innerHeight) * 2 - 1) * 0.3 - 0.15;
}, { passive: true });

document.addEventListener('touchstart', () => {
    if (!audioStarted) startAudio();
}, { passive: true });

// Show controls hint after 2s
setTimeout(() => {
    const hint = document.getElementById('controls-help');
    if (hint) { hint.classList.add('visible'); setTimeout(() => hint.classList.add('fade'), 6000); }
}, 2000);

// ============================================
// AUDIO SYSTEM
// ============================================
function startAudio() {
    if (audioStarted) return;
    audioStarted = true;

    document.getElementById('audio-icon-on').style.display = 'block';
    document.getElementById('audio-icon-off').style.display = 'none';

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Master gain — fade in over 3s
    masterGain = audioCtx.createGain();
    masterGain.gain.setValueAtTime(0, audioCtx.currentTime);
    masterGain.gain.linearRampToValueAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime + 3);
    masterGain.connect(audioCtx.destination);

    // Reverb (procedural impulse, same pattern as lofigen)
    const reverbLength = audioCtx.sampleRate * 4;
    const impulse = audioCtx.createBuffer(2, reverbLength, audioCtx.sampleRate);
    const rr = mulberry32(currentSeed + '_reverb');
    for (let ch = 0; ch < 2; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < reverbLength; i++) {
            const t = i / reverbLength;
            let val = rr() * 2 - 1;
            if (t < 0.05) val *= 0.7;
            val *= Math.exp(-3.0 * t);
            if (t > 0.2) val *= 0.8;
            data[i] = val;
        }
    }
    const reverb = audioCtx.createConvolver();
    reverb.buffer = impulse;

    const reverbGain = audioCtx.createGain();
    reverbGain.gain.value = 0.4;
    reverb.connect(reverbGain);
    reverbGain.connect(masterGain);

    const dryBus = audioCtx.createGain();
    dryBus.gain.value = 0.6;
    dryBus.connect(masterGain);

    const reverbSend = audioCtx.createGain();
    reverbSend.gain.value = 0.5;
    reverbSend.connect(reverb);

    // --- Drone pad: 2 detuned oscillators ---
    function createDrone(freq, type) {
        const osc = audioCtx.createOscillator();
        osc.type = type;
        osc.frequency.value = freq;

        const lpf = audioCtx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.value = 300;
        lpf.Q.value = 1;

        // Slow LPF sweep
        const now = audioCtx.currentTime;
        lpf.frequency.setValueAtTime(200, now);
        function sweepLPF() {
            const t = audioCtx.currentTime;
            lpf.frequency.linearRampToValueAtTime(400 + Math.sin(t * 0.05) * 200, t + 8);
            setTimeout(sweepLPF, 8000);
        }
        sweepLPF();

        const gain = audioCtx.createGain();
        gain.gain.value = 0.06; // quiet drones, spatial emitters are the star

        osc.connect(lpf);
        lpf.connect(gain);
        gain.connect(dryBus);
        gain.connect(reverbSend);
        osc.start();
        droneGainNodes.push(gain);
        return osc;
    }

    // Two drones at ~55Hz (A1) detuned — quieter to let spatial audio breathe
    createDrone(55, 'sine');
    createDrone(55.3, 'triangle');
    createDrone(27.5, 'sine');

    // --- Rain texture: filtered noise ---
    const rainLen = audioCtx.sampleRate * 4;
    const rainBuf = audioCtx.createBuffer(1, rainLen, audioCtx.sampleRate);
    const rainData = rainBuf.getChannelData(0);
    const rainRng = mulberry32(currentSeed + '_rain');
    for (let i = 0; i < rainLen; i++) rainData[i] = rainRng() * 2 - 1;

    const rainSrc = audioCtx.createBufferSource();
    rainSrc.buffer = rainBuf;
    rainSrc.loop = true;

    const rainBP = audioCtx.createBiquadFilter();
    rainBP.type = 'bandpass';
    rainBP.frequency.value = 3000;
    rainBP.Q.value = 0.5;

    const rainHP = audioCtx.createBiquadFilter();
    rainHP.type = 'highpass';
    rainHP.frequency.value = 800;

    const rainGain = audioCtx.createGain();
    rainGain.gain.value = 0.02;
    rainGainNode = rainGain;

    rainSrc.connect(rainBP);
    rainBP.connect(rainHP);
    rainHP.connect(rainGain);
    rainGain.connect(dryBus);
    rainSrc.start();

    // --- Space engine hum: low rumble that fades in at altitude ---
    const humOsc1 = audioCtx.createOscillator(); humOsc1.type = 'sine'; humOsc1.frequency.value = 35;
    const humOsc2 = audioCtx.createOscillator(); humOsc2.type = 'sine'; humOsc2.frequency.value = 35.5; // slight detune
    const humOsc3 = audioCtx.createOscillator(); humOsc3.type = 'triangle'; humOsc3.frequency.value = 17.5; // sub
    const humLpf = audioCtx.createBiquadFilter(); humLpf.type = 'lowpass'; humLpf.frequency.value = 120; humLpf.Q.value = 2;
    // Slow LFO on the LPF for subtle movement
    const humLfo = audioCtx.createOscillator(); humLfo.type = 'sine'; humLfo.frequency.value = 0.07;
    const humLfoG = audioCtx.createGain(); humLfoG.gain.value = 30;
    humLfo.connect(humLfoG); humLfoG.connect(humLpf.frequency);
    spaceHumGain = audioCtx.createGain(); spaceHumGain.gain.value = 0; // starts silent, altitude controls it
    humOsc1.connect(humLpf); humOsc2.connect(humLpf); humOsc3.connect(humLpf);
    humLpf.connect(spaceHumGain); spaceHumGain.connect(dryBus);
    humOsc1.start(); humOsc2.start(); humOsc3.start(); humLfo.start();

    // --- Sparse pentatonic tones ---
    const pentatonic = [0, 2, 4, 7, 9]; // relative to root
    const rootMidi = 60; // C4
    const toneRng = mulberry32(currentSeed + '_tones');

    function scheduleTone() {
        const delay = 5 + toneRng() * 10; // 5-15s between tones
        setTimeout(() => {
            if (!audioCtx || audioCtx.state === 'closed') return;

            const degree = pentatonic[Math.floor(toneRng() * pentatonic.length)];
            const octave = Math.floor(toneRng() * 2); // 0 or 1 octave up
            const midi = rootMidi + degree + octave * 12;
            const freq = 440 * Math.pow(2, (midi - 69) / 12);

            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;

            const env = audioCtx.createGain();
            const now = audioCtx.currentTime;
            const dur = 3 + toneRng() * 5;
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.03 + toneRng() * 0.02, now + dur * 0.3);
            env.gain.linearRampToValueAtTime(0, now + dur);

            osc.connect(env);
            env.connect(dryBus);
            env.connect(reverbSend);
            osc.start(now);
            osc.stop(now + dur + 0.1);

            scheduleTone();
        }, delay * 1000);
    }
    scheduleTone();

    // Init spatial emitters after audio context is ready
    initSpatialAudio();
}

// ============================================
// SPATIAL AUDIO — LOFIGEN-LITE PER-EMITTER SONGS
// ============================================
function cellHash(cx, cz, sd, salt) {
    let v = Math.sin(cx * 127.1 + cz * 311.7 + sd * salt) * 43758.5453;
    return v - Math.floor(v);
}

// Music theory constants
const SCALES = {
    minor: [0,2,3,5,7,8,10], dorian: [0,2,3,5,7,9,10],
    minorPenta: [0,3,5,7,10], majorPenta: [0,2,4,7,9],
};
const SCALE_LIST = Object.values(SCALES);
const CHORD_TYPES = {
    maj7: [0,4,7,11], min7: [0,3,7,10], dom7: [0,4,7,10],
    min9: [0,3,7,10,14], maj9: [0,4,7,11,14], sus4: [0,5,7],
};
const CHORD_LIST = Object.values(CHORD_TYPES);
const PROGRESSIONS = [
    [1,4,5,1], [2,5,1,6], [1,6,4,5], [4,3,2,1],
    [1,3,4,5], [6,4,1,5], [2,5,3,6], [1,4,6,5],
];

function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

// Generate a complete mini-song from a seed
function generateSongParams(seed) {
    const r = mulberry32(Math.floor(seed * 99999));
    const scale = SCALE_LIST[Math.floor(r() * SCALE_LIST.length)];
    const rootMidi = 48 + Math.floor(r() * 8); // C3 to G3
    const bpm = 55 + Math.floor(r() * 20); // 55-75 BPM (ambient)
    const stepDur = 60 / bpm / 4; // sixteenth note
    const swing = 0.1 + r() * 0.15;
    const prog = PROGRESSIONS[Math.floor(r() * PROGRESSIONS.length)];
    const chordType = CHORD_LIST[Math.floor(r() * CHORD_LIST.length)];

    // Build 4 chord voicings
    const chords = prog.map(deg => {
        const idx = (deg - 1) % scale.length;
        const base = rootMidi + scale[idx];
        let notes = chordType.map(iv => base + iv);
        if (r() > 0.5) { notes[0] += 12; notes.sort((a,b) => a-b); }
        return notes;
    });

    // Melody: sparse pentatonic (2-4 notes per bar)
    const melScale = SCALES.minorPenta;
    const melody = [];
    let prevNote = rootMidi + 12 + melScale[Math.floor(r() * melScale.length)];
    for (let bar = 0; bar < 4; bar++) {
        const pat = new Array(16).fill(null);
        if (r() > 0.2) { // 80% chance of melody this bar
            const count = 1 + Math.floor(r() * 3);
            for (let n = 0; n < count; n++) {
                const pos = [0,2,4,6,8,10,12,14][Math.floor(r() * 8)];
                if (pat[pos]) continue;
                const step = Math.floor(r() * 3) - 1;
                const idx = ((Math.round((prevNote - rootMidi) / 2) + step) % melScale.length + melScale.length) % melScale.length;
                let note = rootMidi + 12 + melScale[idx];
                if (r() > 0.5) note += 12;
                while (note > rootMidi + 28) note -= 12;
                while (note < rootMidi + 5) note += 12;
                prevNote = note;
                pat[pos] = { note, dur: 2 + Math.floor(r() * 4), vel: 0.3 + r() * 0.25 };
            }
        }
        melody.push(pat);
    }

    // Bass: root on beat 1, fifth on beat 3
    const bass = chords.map((chord, i) => {
        const pat = new Array(16).fill(null);
        const root = chord[0] - 12;
        pat[0] = { note: root, vel: 0.7 + r() * 0.2 };
        if (r() > 0.3) pat[8] = { note: root + 7, vel: 0.5 };
        if (r() > 0.6) pat[Math.floor(r() * 4) * 4] = { note: root + scale[Math.floor(r() * scale.length)], vel: 0.35 };
        return pat;
    });

    // Timbre choices
    const keysType = Math.floor(r() * 3); // 0=fm, 1=triangle, 2=musicbox
    const melType = Math.floor(r() * 3);  // 0=sine+tri, 1=bell, 2=fm
    const bassType = Math.floor(r() * 2); // 0=triangle, 1=sine

    return { scale, rootMidi, bpm, stepDur, swing, chords, melody, bass, keysType, melType, bassType, seed };
}

// Play a note through an emitter's audio chain
function playNote(emBus, freq, time, dur, vol, type) {
    if (!audioCtx || audioCtx.state !== 'running') return;
    const ctx = audioCtx;

    if (type === 'keys') {
        // FM Rhodes-style: carrier + modulator + detuned 2nd voice
        const mod = ctx.createOscillator(); mod.type = 'sine'; mod.frequency.value = freq * 2.001;
        const mg = ctx.createGain();
        mg.gain.setValueAtTime(freq * 0.6, time);
        mg.gain.exponentialRampToValueAtTime(Math.max(freq * 0.05, 1), time + dur * 0.5);
        mod.connect(mg);
        const car = ctx.createOscillator(); car.type = 'sine'; car.frequency.value = freq;
        mg.connect(car.frequency);
        const car2 = ctx.createOscillator(); car2.type = 'sine'; car2.frequency.value = freq * 1.003;
        const c2g = ctx.createGain(); c2g.gain.value = 0.25; car2.connect(c2g);
        const lpf = ctx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.Q.value = 0.5;
        lpf.frequency.setValueAtTime(2000, time);
        lpf.frequency.exponentialRampToValueAtTime(Math.max(600, 1), time + dur * 0.6);
        const env = ctx.createGain();
        env.gain.setValueAtTime(0, time);
        env.gain.linearRampToValueAtTime(vol, time + 0.015);
        env.gain.exponentialRampToValueAtTime(Math.max(vol * 0.3, 0.001), time + dur * 0.5);
        env.gain.exponentialRampToValueAtTime(0.001, time + dur);
        car.connect(lpf); c2g.connect(lpf); lpf.connect(env); env.connect(emBus);
        mod.start(time); mod.stop(time + dur + 0.1);
        car.start(time); car.stop(time + dur + 0.1);
        car2.start(time); car2.stop(time + dur + 0.1);
    } else if (type === 'melody') {
        // Sine + triangle with vibrato
        const osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = freq;
        const tri = ctx.createOscillator(); tri.type = 'triangle'; tri.frequency.value = freq;
        const tg = ctx.createGain(); tg.gain.value = 0.2; tri.connect(tg);
        const vib = ctx.createOscillator(); vib.type = 'sine'; vib.frequency.value = 4.5;
        const vd = ctx.createGain(); vd.gain.value = freq * 0.004;
        vib.connect(vd); vd.connect(osc.frequency); vd.connect(tri.frequency);
        const lpf = ctx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.frequency.value = 2200;
        const env = ctx.createGain();
        env.gain.setValueAtTime(0, time);
        env.gain.linearRampToValueAtTime(vol, time + 0.04);
        env.gain.exponentialRampToValueAtTime(Math.max(vol * 0.5, 0.001), time + dur * 0.5);
        env.gain.exponentialRampToValueAtTime(0.001, time + dur);
        osc.connect(lpf); tg.connect(lpf); lpf.connect(env); env.connect(emBus);
        vib.start(time); vib.stop(time + dur + 0.1);
        osc.start(time); osc.stop(time + dur + 0.1);
        tri.start(time); tri.stop(time + dur + 0.1);
    } else if (type === 'bass') {
        // Triangle + sine sub
        const osc = ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = freq;
        const sub = ctx.createOscillator(); sub.type = 'sine'; sub.frequency.value = freq * 0.5;
        const sg = ctx.createGain(); sg.gain.value = 0.5; sub.connect(sg);
        const lpf = ctx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.Q.value = 1.5;
        lpf.frequency.setValueAtTime(1000, time);
        lpf.frequency.exponentialRampToValueAtTime(Math.max(300, 1), time + dur * 0.3);
        const env = ctx.createGain();
        env.gain.setValueAtTime(0, time);
        env.gain.linearRampToValueAtTime(vol, time + 0.01);
        env.gain.exponentialRampToValueAtTime(Math.max(vol * 0.4, 0.001), time + dur * 0.4);
        env.gain.exponentialRampToValueAtTime(0.001, time + dur);
        osc.connect(lpf); sg.connect(lpf); lpf.connect(env); env.connect(emBus);
        osc.start(time); osc.stop(time + dur + 0.05);
        sub.start(time); sub.stop(time + dur + 0.05);
    } else if (type === 'pad') {
        // Detuned saws through heavy LPF
        const o1 = ctx.createOscillator(); o1.type = 'sawtooth'; o1.frequency.value = freq * 0.998;
        const o2 = ctx.createOscillator(); o2.type = 'sawtooth'; o2.frequency.value = freq * 1.002;
        const lpf = ctx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.Q.value = 1;
        lpf.frequency.setValueAtTime(500, time);
        lpf.frequency.linearRampToValueAtTime(800, time + dur * 0.3);
        lpf.frequency.linearRampToValueAtTime(400, time + dur);
        const env = ctx.createGain();
        env.gain.setValueAtTime(0, time);
        env.gain.linearRampToValueAtTime(vol, time + dur * 0.3);
        env.gain.linearRampToValueAtTime(0, time + dur);
        o1.connect(lpf); o2.connect(lpf); lpf.connect(env); env.connect(emBus);
        o1.start(time); o1.stop(time + dur + 0.1);
        o2.start(time); o2.stop(time + dur + 0.1);
    }
}

const EMITTER_POOL_SIZE = 8; // fewer but richer
let emitterPool = [];
let spatialBus = null;
let spatialReverbSend = null;
let spatialDebugTimer = 0;
let spatialDebugCount = 0;

function initSpatialAudio() {
    if (!audioCtx || !masterGain) return;

    spatialBus = audioCtx.createGain();
    spatialBus.gain.value = 1.0;
    spatialBus.connect(masterGain);

    spatialReverbSend = audioCtx.createGain();
    spatialReverbSend.gain.value = 0.35;
    spatialReverbSend.connect(masterGain);

    for (let i = 0; i < EMITTER_POOL_SIZE; i++) {
        const pan = audioCtx.createStereoPanner(); pan.pan.value = 0;
        const gain = audioCtx.createGain(); gain.gain.value = 0;
        const lpf = audioCtx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.frequency.value = 4000; lpf.Q.value = 0.5;
        // Reverb send per emitter
        const reverbGain = audioCtx.createGain(); reverbGain.gain.value = 0.4;

        lpf.connect(gain);
        gain.connect(pan);
        pan.connect(spatialBus);
        gain.connect(reverbGain);
        reverbGain.connect(spatialReverbSend);

        emitterPool.push({
            pan, gain, lpf, reverbGain,
            // Song bus: notes connect here → lpf → gain → pan → spatial
            bus: lpf, // notes connect to this node
            key: null, type: 0, targetGain: 0, curGain: 0,
            song: null, // song params
            scheduler: null, // interval ID
            step: 0, bar: 0, nextStepTime: 0,
        });
    }
    dbg(true, `Spatial audio: ${EMITTER_POOL_SIZE} lofigen emitters ready`);
}

// Start a song on an emitter
function startEmitterSong(em, obj) {
    const song = generateSongParams(obj.h + obj.type * 0.1);
    em.song = song;
    // Skip to mid-song — each emitter starts at a different bar (2-6)
    // so we never hear a bunch of intros at once
    em.bar = 2 + Math.floor(obj.h * 5); // bar 2 to 6
    em.step = Math.floor(obj.h * 13 * 16) % 16; // random step within bar
    em.nextStepTime = audioCtx.currentTime + 0.05;

    // Scheduler: 25ms tick, same as lofigen
    if (em.scheduler) clearInterval(em.scheduler);
    em.scheduler = setInterval(() => {
        if (!audioCtx || audioCtx.state !== 'running' || !em.key) return;
        const lookAhead = 0.12;
        while (em.nextStepTime < audioCtx.currentTime + lookAhead) {
            scheduleEmitterStep(em, em.nextStepTime, em.step);
            let dur = song.stepDur;
            if (em.step % 2 === 1) dur += song.stepDur * song.swing;
            em.nextStepTime += dur;
            em.step++;
            if (em.step >= 16) { em.step = 0; em.bar++; }
        }
    }, 25);
}

function scheduleEmitterStep(em, time, step) {
    const s = em.song;
    const chordIdx = em.bar % s.chords.length;
    const chord = s.chords[chordIdx];
    const barDur = s.stepDur * 16;
    const vol = 0.12; // per-emitter base volume

    // Keys chord on beat 1
    if (step === 0) {
        for (const midi of chord) {
            playNote(em.bus, midiToFreq(midi), time, barDur * 0.9, vol * 0.5, 'keys');
        }
        // Pad every other bar
        if (em.bar % 2 === 0) {
            playNote(em.bus, midiToFreq(chord[0]), time, barDur * 1.1, vol * 0.25, 'pad');
        }
    }

    // Bass
    const bassPat = s.bass[chordIdx];
    if (bassPat[step]) {
        const { note, vel } = bassPat[step];
        let dur = s.stepDur * 2;
        for (let i = step + 1; i < 16; i++) { if (bassPat[i]) break; dur += s.stepDur; }
        playNote(em.bus, midiToFreq(note), time, Math.min(dur, s.stepDur * 8), vol * vel * 0.7, 'bass');
    }

    // Melody
    const melPat = s.melody[chordIdx];
    if (melPat[step]) {
        const { note, dur, vel } = melPat[step];
        playNote(em.bus, midiToFreq(note), time, s.stepDur * dur, vol * vel * 0.6, 'melody');
    }
}

function stopEmitterSong(em) {
    if (em.scheduler) { clearInterval(em.scheduler); em.scheduler = null; }
    em.song = null;
}

// Find nearby objects
function findNearbyObjects(cx, cy, cz, sd) {
    const objs = [];
    // Spheres (cell=40)
    const sp = 40, sx0 = Math.floor(cx/sp), sz0 = Math.floor(cz/sp);
    for (let dx=-2;dx<=2;dx++) for (let dz=-2;dz<=2;dz++) {
        const gx=sx0+dx, gz=sz0+dz, h=cellHash(gx,gz,sd,31);
        if (h<0.4) { const ox=gx*sp+sp*0.5+(h*2-1)*10, oz=gz*sp+sp*0.5+((h*7.7%1)*2-1)*10;
            const d=Math.hypot(cx-ox,cy-3,cz-oz); if(d<150) objs.push({type:1,x:ox,y:3,z:oz,d,key:`s${gx}_${gz}`,h}); }
    }
    // Crystals (cell=30)
    const cr=30, cx0=Math.floor(cx/cr), cz0=Math.floor(cz/cr);
    for (let dx=-2;dx<=2;dx++) for (let dz=-2;dz<=2;dz++) {
        const gx=cx0+dx, gz=cz0+dz, h=cellHash(gx,gz,sd,59);
        if (h<0.15) { const ox=gx*cr+cr*0.5+(h*2-1)*8, oz=gz*cr+cr*0.5+((h*11%1)*2-1)*8;
            const d=Math.hypot(cx-ox,cy-4,cz-oz); if(d<120) objs.push({type:4,x:ox,y:4,z:oz,d,key:`x${gx}_${gz}`,h}); }
    }
    // Cairns (cell=55)
    const ca=55, ca0=Math.floor(cx/ca), caz=Math.floor(cz/ca);
    for (let dx=-2;dx<=2;dx++) for (let dz=-2;dz<=2;dz++) {
        const gx=ca0+dx, gz=caz+dz, h=cellHash(gx,gz,sd,83);
        if (h<0.12) { const ox=gx*ca+ca*0.5+(h*2-1)*15, oz=gz*ca+ca*0.5+((h*9%1)*2-1)*15;
            const d=Math.hypot(cx-ox,cy-3,cz-oz); if(d<130) objs.push({type:5,x:ox,y:3,z:oz,d,key:`n${gx}_${gz}`,h}); }
    }
    // Structures (cell=120)
    const bg=120, bg0=Math.floor(cx/bg), bgz=Math.floor(cz/bg);
    for (let dx=-2;dx<=2;dx++) for (let dz=-2;dz<=2;dz++) {
        const gx=bg0+dx, gz=bgz+dz, h=cellHash(gx,gz,sd,73);
        if (h<0.25) { const ox=gx*bg+bg*0.5+(h*2-1)*30, oz=gz*bg+bg*0.5+((h*13.37%1)*2-1)*30;
            const d=Math.hypot(cx-ox,cy-6,cz-oz); if(d<180) objs.push({type:3,x:ox,y:6,z:oz,d,key:`b${gx}_${gz}`,h}); }
    }
    objs.sort((a,b) => a.d - b.d);
    return objs;
}

function updateSpatialAudio(dt, elapsed) {
    if (!audioCtx || audioCtx.state !== 'running' || emitterPool.length === 0) return;

    const nearby = findNearbyObjects(camX, camY, camZ, currentSeedFloat);
    const now = audioCtx.currentTime;

    spatialDebugTimer += dt;
    if (spatialDebugTimer > 3) {
        spatialDebugTimer = 0;
        const active = emitterPool.filter(e => e.key && e.curGain > 0.001).length;
        if (spatialDebugCount < 5) {
            dbg(nearby.length > 0, `Spatial: ${nearby.length} nearby, ${active} songs playing`);
            spatialDebugCount++;
        }
    }

    const rightX = Math.cos(camYaw), rightZ = -Math.sin(camYaw);

    const wantKeys = new Map();
    for (let i = 0; i < Math.min(nearby.length, EMITTER_POOL_SIZE); i++) {
        wantKeys.set(nearby[i].key, nearby[i]);
    }

    // Release emitters not in want list — stop their songs
    for (const em of emitterPool) {
        if (em.key && !wantKeys.has(em.key)) {
            stopEmitterSong(em);
            em.key = null;
            em.targetGain = 0;
        }
    }

    // Assign + update
    for (const [key, obj] of wantKeys) {
        let em = emitterPool.find(e => e.key === key);
        if (!em) {
            em = emitterPool.find(e => !e.key);
            if (!em) continue;
            em.key = key;
            em.type = obj.type;
            startEmitterSong(em, obj); // launch lofigen song!
        }

        // Distance attenuation — large radius, gentle falloff
        const maxDist = 120;
        const norm = Math.min(obj.d / maxDist, 1);
        em.targetGain = (1 - norm) * (1 - norm) * 0.5;

        // LPF with distance
        const baseLpf = em.type === 4 ? 5000 : em.type === 3 ? 500 : 1500;
        em.lpf.frequency.setTargetAtTime(Math.max(baseLpf * (1 - norm * 0.7), 200), now, 0.3);

        // Stereo pan
        const dx = obj.x - camX, dz = obj.z - camZ;
        const dot = dx * rightX + dz * rightZ;
        em.pan.pan.setTargetAtTime(Math.max(-1, Math.min(1, dot / Math.max(obj.d, 1))), now, 0.1);
    }

    // Smooth gains
    for (const em of emitterPool) {
        em.curGain += (em.targetGain - em.curGain) * (1 - Math.exp(-5 * dt));
        em.gain.gain.setTargetAtTime(Math.max(em.curGain, 0.0001), now, 0.05);
    }
}

function toggleAudio() {
    if (!audioStarted) {
        startAudio();
        return;
    }
    if (!audioCtx) return;

    const onIcon = document.getElementById('audio-icon-on');
    const offIcon = document.getElementById('audio-icon-off');

    if (audioCtx.state === 'running') {
        masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
        setTimeout(() => audioCtx.suspend(), 500);
        onIcon.style.display = 'none';
        offIcon.style.display = 'block';
    } else {
        audioCtx.resume();
        masterGain.gain.setTargetAtTime(volumeSlider.value / 100 * 0.3, audioCtx.currentTime, 0.3);
        onIcon.style.display = 'block';
        offIcon.style.display = 'none';
    }
}

// ============================================
// RESIZE + ADAPTIVE QUALITY
// ============================================
function resize() {
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    canvas.width = w;
    canvas.height = h;
    gl.viewport(0, 0, w, h);
    dbg(w > 0 && h > 0, `Canvas resized: ${w}x${h} (dpr=${dpr})`);
}

window.addEventListener('resize', resize);
resize();

loadProgress(80, 'first render...');
await yieldFrame();

// Warm draw — triggers GPU pipeline compilation (already compiled via parallel extension above)
gl.uniform2f(uRes, canvas.width, canvas.height);
gl.uniform1f(uTime, 0); gl.uniform1f(uSpeed, 0.3);
gl.uniform3f(uCamPos, 0, 3.5, 0);
gl.uniform3f(uCamFwd, 0, 0, 1); gl.uniform3f(uCamRight, 1, 0, 0); gl.uniform3f(uCamUp, 0, 1, 0);
gl.uniform1f(uBreath, 0); gl.uniform1f(uSeed, currentSeedFloat);
gl.uniform1f(uTransition, 0); gl.uniform1f(uPrevSeed, currentSeedFloat);
gl.uniform1f(uMobile, isMobile ? 1.0 : 0.0); gl.uniform1f(uVelocity, 0);
gl.drawArrays(gl.TRIANGLES, 0, 3);
// Don't gl.finish() — let the first frame pipeline compile overlap with JS init
await yieldFrame();
await yieldFrame(); // two frames ensures the pipeline is warmed

loadProgress(95, 'ready');

// Dismiss loading screen
loadProgress(100, '');
loadScreen.classList.add('done');
setTimeout(() => loadScreen.style.display = 'none', 1600);

dbg(true, `Seed: "${currentSeed}" -> float: ${currentSeedFloat}`);
dbg(!isMobile, `Device: ${isMobile ? 'mobile' : 'desktop'}`);

// ============================================
// HUD ELEMENTS
// ============================================
const hudFps = document.getElementById('hud-fps');
const hudRes = document.getElementById('hud-res');
const hudSeed = document.getElementById('hud-seed');
const hudDpr = document.getElementById('hud-dpr');
const hudPos = document.getElementById('hud-pos');
const hudYaw = document.getElementById('hud-yaw');
const hudTime = document.getElementById('hud-time');
const hudMode = document.getElementById('hud-mode');
const hudSpeed = document.getElementById('hud-speed');
const breathFill = document.getElementById('breath-fill');

// Altitude graph
const altCanvas = document.getElementById('alt-canvas');
const altCtx = altCanvas.getContext('2d');
const ALT_HISTORY_LEN = 200;
const altHistory = new Float32Array(ALT_HISTORY_LEN); // ring buffer
let altHistIdx = 0;
const ALT_MAX = 150; // max altitude for graph scale

// ============================================
// AMBIENT CLOCK
// ============================================
const clockEl = document.getElementById('ambient-clock');
function updateClock() {
    const d = new Date();
    const h = d.getHours() % 12 || 12;
    const m = String(d.getMinutes()).padStart(2, '0');
    clockEl.textContent = `${h}:${m}`;
}
updateClock();
setInterval(updateClock, 10000);
// Fade in after 5s
setTimeout(() => clockEl.classList.add('visible'), 5000);

// ============================================
// QUOTES
// ============================================
const quotes = [
    "breathe in. breathe out.",
    "you are exactly where you need to be.",
    "the present moment is all there is.",
    "let the thoughts drift by like clouds.",
    "nothing to fix. nothing to solve. just be.",
    "the mind is like water — calm it and everything becomes clear.",
    "rest is not idleness.",
    "you don't have to figure it all out today.",
    "between stimulus and response there is a space.",
    "be still and know.",
    "progress is not always visible.",
    "the quieter you become, the more you can hear.",
    "this too shall pass.",
    "you are not your thoughts.",
    "slow down. you're doing fine.",
    "one breath at a time.",
];
const quoteEl = document.getElementById('quote');
let quoteIdx = Math.floor(Math.random() * quotes.length);
function showQuote() {
    quoteEl.classList.remove('visible');
    setTimeout(() => {
        quoteEl.textContent = quotes[quoteIdx % quotes.length];
        quoteIdx++;
        quoteEl.classList.add('visible');
        // Fade out after 12s
        setTimeout(() => quoteEl.classList.remove('visible'), 12000);
    }, 4000);
}
// First quote after 10s, then every 45-90s
setTimeout(showQuote, 10000);
setInterval(showQuote, 45000 + Math.random() * 45000);

// ============================================
// POMODORO TIMER
// ============================================
const pomoDisplay = document.getElementById('pomo-display');
const pomoLabel = document.getElementById('pomo-label');
const pomoFill = document.getElementById('pomo-fill');
const pomoBtn = document.getElementById('pomo-btn');

let pomoState = 'idle'; // idle, focus, break
let pomoRemaining = 25 * 60; // seconds
let pomoTotal = 25 * 60;
let pomoInterval = null;
let pomoSessions = 0;

const FOCUS_MINUTES = 25;
const SHORT_BREAK = 5;
const LONG_BREAK = 15;

function formatPomo(secs) {
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    return `${m}:${String(s).padStart(2, '0')}`;
}

function pomoPing() {
    // Gentle audio cue if audio is active
    if (audioCtx && audioCtx.state === 'running') {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 528; // solfeggio
        const env = audioCtx.createGain();
        const now = audioCtx.currentTime;
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.08, now + 0.3);
        env.gain.linearRampToValueAtTime(0, now + 2.5);
        osc.connect(env);
        env.connect(masterGain);
        osc.start(now);
        osc.stop(now + 3);
        // Second tone
        setTimeout(() => {
            const osc2 = audioCtx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 639;
            const env2 = audioCtx.createGain();
            const n2 = audioCtx.currentTime;
            env2.gain.setValueAtTime(0, n2);
            env2.gain.linearRampToValueAtTime(0.06, n2 + 0.3);
            env2.gain.linearRampToValueAtTime(0, n2 + 2);
            osc2.connect(env2);
            env2.connect(masterGain);
            osc2.start(n2);
            osc2.stop(n2 + 2.5);
        }, 800);
    }
}

function startPomo() {
    if (pomoState === 'idle' || pomoState === 'done') {
        pomoState = 'focus';
        pomoTotal = FOCUS_MINUTES * 60;
        pomoRemaining = pomoTotal;
        pomoLabel.textContent = 'focus';
        pomoFill.style.background = 'rgba(180,170,160,0.3)';
        pomoBtn.textContent = 'stop';
    } else if (pomoState === 'focus' || pomoState === 'break') {
        // Stop
        clearInterval(pomoInterval);
        pomoInterval = null;
        pomoState = 'idle';
        pomoRemaining = FOCUS_MINUTES * 60;
        pomoTotal = pomoRemaining;
        pomoLabel.textContent = 'focus';
        pomoBtn.textContent = 'start';
        pomoDisplay.textContent = formatPomo(pomoRemaining);
        pomoFill.style.width = '0%';
        return;
    }

    clearInterval(pomoInterval);
    pomoInterval = setInterval(() => {
        pomoRemaining--;
        if (pomoRemaining <= 0) {
            clearInterval(pomoInterval);
            pomoPing();

            if (pomoState === 'focus') {
                pomoSessions++;
                // Switch to break
                pomoState = 'break';
                const breakLen = (pomoSessions % 4 === 0) ? LONG_BREAK : SHORT_BREAK;
                pomoTotal = breakLen * 60;
                pomoRemaining = pomoTotal;
                pomoLabel.textContent = (pomoSessions % 4 === 0) ? 'long break' : 'break';
                pomoFill.style.background = 'rgba(120,180,140,0.3)';
                pomoBtn.textContent = 'skip';
                // Auto-start break
                pomoInterval = setInterval(arguments.callee, 1000);
            } else {
                // Break done
                pomoState = 'done';
                pomoLabel.textContent = 'done';
                pomoBtn.textContent = 'start';
                pomoPing();
            }
        }
        pomoDisplay.textContent = formatPomo(pomoRemaining);
        const pct = ((pomoTotal - pomoRemaining) / pomoTotal) * 100;
        pomoFill.style.width = `${pct}%`;
    }, 1000);
}

pomoBtn.addEventListener('click', startPomo);
pomoDisplay.textContent = formatPomo(pomoRemaining);

// ============================================
// RENDER LOOP
// ============================================
const startTime = performance.now();
let lastFrame = startTime;
let debugFrames = 0;
let hudTimer = 0;

function frame(now) {
    requestAnimationFrame(frame);
    debugFrames++;
    if (debugFrames === 1) dbg(true, 'First frame rendering');
    if (debugFrames === 5) {
        const err = gl.getError();
        dbg(err === gl.NO_ERROR, `WebGL error check: ${err === gl.NO_ERROR ? 'none' : 'ERROR ' + err}`);
        const px = new Uint8Array(4);
        gl.readPixels(Math.floor(canvas.width/2), Math.floor(canvas.height/2), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
        const bright = px[0] + px[1] + px[2];
        dbg(bright > 0, `Center pixel: rgb(${px[0]},${px[1]},${px[2]}) — ${bright > 0 ? 'visible' : 'BLACK'}`);
    }

    const dt = Math.min((now - lastFrame) / 1000, 0.1); // cap dt
    lastFrame = now;

    // Ramp DPR up over first 3 seconds for smooth startup
    dprRampTimer += dt;
    if (dprRampTimer < 3.0 && dpr < targetDpr) {
        dpr = Math.min(targetDpr, dpr + dt * (targetDpr / 3.0));
        resize();
    }

    // Adaptive FPS check
    frameCount++;
    fpsAccum += dt;
    if (fpsAccum > 1) {
        currentFps = Math.round(frameCount / fpsAccum);
        if (currentFps < 28 && dpr > 0.5) {
            dpr = Math.max(0.5, dpr - 0.25);
            resize();
        }
        frameCount = 0;
        fpsAccum = 0;
    }

    const elapsed = (now - startTime) / 1000;
    const time = elapsed * speedMul;

    // ---- Camera ----
    // Forward/right vectors from yaw (horizontal plane, matches shader cam)
    const fwdX = Math.sin(camYaw);
    const fwdZ = Math.cos(camYaw);
    const rightX = Math.cos(camYaw);
    const rightZ = -Math.sin(camYaw);

    // Check for any active input
    const anyInput = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'] ||
                     keys['Space'] || keys['ShiftLeft'] || keys['ShiftRight'];

    if (flyMode && anyInput) {
        idleTimer = 0;
    } else if (flyMode) {
        idleTimer += dt;
        if (idleTimer >= IDLE_TIMEOUT) {
            flyMode = false;
            // Don't snap — drift will continue from current position
            // Keep driftTime rolling so the journey continues seamlessly
        }
    }

    if (flyMode) {
        // WASD input
        let inputX = 0, inputY = 0, inputZ = 0;
        if (keys['KeyW']) { inputX += fwdX; inputZ += fwdZ; }
        if (keys['KeyS']) { inputX -= fwdX; inputZ -= fwdZ; }
        if (keys['KeyD']) { inputX += rightX; inputZ += rightZ; }
        if (keys['KeyA']) { inputX -= rightX; inputZ -= rightZ; }
        if (keys['Space']) inputY += 1;
        if (keys['ShiftLeft'] || keys['ShiftRight']) inputY -= 1;

        const len = Math.sqrt(inputX*inputX + inputY*inputY + inputZ*inputZ);
        if (len > 0) {
            const spd = moveSpeed * flySpeedMul;
            velX += (inputX/len) * spd * dt;
            velY += (inputY/len) * spd * dt;
            velZ += (inputZ/len) * spd * dt;
        }

        velX *= camDamping;
        velY *= camDamping;
        velZ *= camDamping;

        camX += velX * dt * 10;
        camY += velY * dt * 10;
        camZ += velZ * dt * 10;
    } else {
        // Auto-drift — cinematic flight
        driftTime += dt;

        // Varying forward speed — faster sometimes, slower through interesting spots
        const speedWave = 0.7 + Math.sin(driftTime / 11.0 + driftPhase) * 0.3
                            + Math.sin(driftTime / 4.5 + driftPhase * 2.1) * 0.15;
        const driftSpeed = 2.5 * flySpeedMul * speedWave;
        camX += Math.sin(camYaw) * driftSpeed * dt;
        camZ += Math.cos(camYaw) * driftSpeed * dt;

        // Altitude: mostly terrain-skimming (y=2-12), rare space trips
        const t1 = driftTime / 18.0 + driftPhase;
        const t2 = driftTime / 6.0 + driftPhase * 1.7;
        const t3 = driftTime / 150.0 + driftPhase * 0.3;

        const lowWave = (Math.sin(t1 * Math.PI * 2) * 0.5
                       + Math.sin(t2 * Math.PI * 2) * 0.25) * 0.5 + 0.5;
        const lowY = 1.5 + lowWave * 10.0;

        // Space spike — brief punch through atmosphere
        const spaceRaw = Math.sin(t3 * Math.PI * 2);
        const spaceGate = Math.max(0, (spaceRaw - 0.88) / 0.12);
        const spacePulse = spaceGate * spaceGate;
        const spaceY = spacePulse * 130.0;

        const targetY = lowY + spaceY;
        const altErr = Math.abs(targetY - camY);
        const lerpRate = altErr > 20 ? 2.0 : 1.0;
        camY += (targetY - camY) * lerpRate * dt;

        // Organic yaw — lazy S-curves with overlapping sines
        const yawDrift = Math.sin(driftTime / 25.0 + driftPhase * 3.0) * 0.03
                       + Math.sin(driftTime / 9.0 + driftPhase * 0.7) * 0.015
                       + Math.sin(driftTime / 45.0 + driftPhase * 1.5) * 0.04;
        camYaw += yawDrift * dt;

        // Pitch — look slightly down at terrain, up during climbs
        const altDelta = targetY - camY;
        const basePitch = -0.12 + Math.sin(driftTime / 14.0) * 0.04;
        const climbPitch = Math.max(-0.7, Math.min(0.35, altDelta * 0.025));
        const pitchTarget = basePitch + climbPitch;
        camPitch += (pitchTarget - camPitch) * 1.2 * dt;
    }

    // Floor clamp — allow slightly underground but not fully
    if (camY < -2.0) {
        camY = -2.0;
        if (velY < 0) velY = 0;
    }

    // Build camera basis vectors (with pitch)
    const cp = Math.cos(camPitch), sp = Math.sin(camPitch);
    const cy = Math.cos(camYaw), sy = Math.sin(camYaw);
    // Forward (into screen)
    const cfX = sy * cp;
    const cfY = sp;
    const cfZ = cy * cp;
    // Right
    const crX = cy;
    const crY = 0;
    const crZ = -sy;
    // Up = forward x right
    const cuX = cfY*crZ - cfZ*crY;
    const cuY = cfZ*crX - cfX*crZ;
    const cuZ = cfX*crY - cfY*crX;

    // Breathing cycle: 12s period — faster when moving faster
    const breathRate = 1.0 + (flySpeedMul - 1.0) * 0.5; // scale pulse speed with fly speed
    const breath = Math.sin(elapsed * Math.PI * 2 / 12 * breathRate);

    // Seed transition crossfade
    if (transition > 0) {
        transition = Math.max(0, transition - dt / 2.5);
    }

    // ---- Uniforms ----
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform1f(uTime, elapsed);
    gl.uniform1f(uSpeed, speedMul * breathRate);
    gl.uniform3f(uCamPos, camX, camY, camZ);
    gl.uniform3f(uCamFwd, cfX, cfY, cfZ);
    gl.uniform3f(uCamRight, crX, crY, crZ);
    gl.uniform3f(uCamUp, cuX, cuY, cuZ);
    gl.uniform1f(uBreath, breath);
    gl.uniform1f(uSeed, currentSeedFloat);
    gl.uniform1f(uTransition, transition);
    gl.uniform1f(uPrevSeed, prevSeedFloat);
    gl.uniform1f(uMobile, isMobile ? 1.0 : 0.0);
    // Velocity magnitude for speed lines
    const camVelocity = Math.sqrt(velX*velX + velY*velY + velZ*velZ) * 10;
    // In drift mode, use drift speed
    const effectiveVel = flyMode ? camVelocity : 2.0 * flySpeedMul + Math.abs(camY - 3.5) * 0.1;
    gl.uniform1f(uVelocity, effectiveVel);

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    // ---- Altitude-based audio mix ----
    if (audioCtx && masterGain && audioCtx.state === 'running') {
        const alt = Math.max(camY, 0);
        const now2 = audioCtx.currentTime;

        // Spatial emitters: full at ground, fade by y=120 (larger radius now)
        const spatialFade = Math.max(0, 1 - alt / 120);
        if (spatialBus) spatialBus.gain.setTargetAtTime(spatialFade * spatialFade, now2, 0.3);

        // Drones: full at ground, muffle in clouds, thin atmospheric hum persists into space
        // Ground: 0.06, clouds: 0.035, upper atmo: 0.015, space: 0.008 (never silent)
        const droneVol = alt < 15 ? 0.06
                       : alt < 40 ? 0.06 - (alt - 15) * 0.001
                       : alt < 100 ? 0.035 - (alt - 40) * 0.0003
                       : 0.008; // faint hum even in space
        for (const dg of droneGainNodes) {
            dg.gain.setTargetAtTime(Math.max(droneVol, 0.005), now2, 0.5);
        }

        // Rain: louder in clouds (wind), fades in upper atmo, gone in space
        const rainVol = alt < 10 ? 0.02
                      : alt < 40 ? 0.02 + (alt - 10) * 0.0006 // peaks ~0.038 in clouds
                      : Math.max(0, 0.038 - (alt - 40) * 0.0006); // fades by ~100
        if (rainGainNode) rainGainNode.gain.setTargetAtTime(rainVol, now2, 0.5);

        // Space engine hum — low rumble that fades in above y=60
        if (spaceHumGain) {
            const humVol = alt > 60 ? Math.min((alt - 60) / 80, 1.0) * 0.04 : 0;
            spaceHumGain.gain.setTargetAtTime(humVol, now2, 0.8);
        }

        altAudioFade = Math.max(0.05, 1 - Math.max(0, alt - 15) / 120); // never fully silent
    }

    // ---- Spatial audio update ----
    updateSpatialAudio(dt, elapsed);

    // ---- HUD update (throttled) ----
    hudTimer += dt;
    if (hudTimer > 0.2) {
        hudTimer = 0;
        hudFps.textContent = `${currentFps} fps`;
        hudRes.textContent = `${canvas.width}x${canvas.height}`;
        hudSeed.textContent = `seed: ${currentSeed}`;
        hudDpr.textContent = `dpr: ${dpr.toFixed(2)}`;
        hudPos.textContent = `pos: ${camX.toFixed(1)}, ${camY.toFixed(1)}, ${camZ.toFixed(1)}`;
        hudYaw.textContent = `yaw: ${(camYaw*180/Math.PI).toFixed(0)} pitch: ${(camPitch*180/Math.PI).toFixed(0)}`;
        hudTime.textContent = `time: ${elapsed.toFixed(1)}s`;
        const zone = camY < 0 ? 'underground' : camY < 15 ? 'surface' : camY < 50 ? 'clouds' : camY < 120 ? 'upper atmosphere' : 'space';
        hudMode.textContent = `mode: ${flyMode ? 'fly' : 'drift'}${pointerLocked ? ' [locked]' : ''} | ${zone}`;
        hudSpeed.textContent = `speed: ${flySpeedMul.toFixed(1)}x`;
        const activeEmitters = emitterPool.filter(e => e.key && e.curGain > 0.001).length;
        hudDpr.textContent = `dpr: ${dpr.toFixed(2)} | emitters: ${activeEmitters}/${EMITTER_POOL_SIZE}`;
        breathFill.style.width = `${(breath * 0.5 + 0.5) * 100}%`;

        // Altitude graph
        altHistory[altHistIdx % ALT_HISTORY_LEN] = Math.max(0, camY);
        altHistIdx++;
        const aw = altCanvas.width, ah = altCanvas.height;
        altCtx.clearRect(0, 0, aw, ah);

        // Zone bands (ground, clouds, upper atmo, space)
        const zones = [
            { y: 0, h: 15, color: 'rgba(100,180,100,0.08)' },
            { y: 15, h: 35, color: 'rgba(180,180,200,0.08)' },
            { y: 50, h: 70, color: 'rgba(100,120,200,0.06)' },
            { y: 120, h: 30, color: 'rgba(40,20,80,0.06)' },
        ];
        for (const z of zones) {
            const top = ah - (z.y + z.h) / ALT_MAX * ah;
            const height = z.h / ALT_MAX * ah;
            altCtx.fillStyle = z.color;
            altCtx.fillRect(0, Math.max(0, top), aw, height);
        }

        // Draw altitude line
        altCtx.strokeStyle = 'rgba(220,215,200,0.6)';
        altCtx.lineWidth = 1.5;
        altCtx.beginPath();
        for (let i = 0; i < ALT_HISTORY_LEN; i++) {
            const idx = (altHistIdx + i) % ALT_HISTORY_LEN;
            const x = (i / ALT_HISTORY_LEN) * aw;
            const y = ah - (altHistory[idx] / ALT_MAX) * ah;
            if (i === 0) altCtx.moveTo(x, y); else altCtx.lineTo(x, y);
        }
        altCtx.stroke();

        // Current position dot
        const curX = aw - 1;
        const curAltY = ah - (Math.max(0, camY) / ALT_MAX) * ah;
        altCtx.fillStyle = 'rgba(255,220,150,0.9)';
        altCtx.beginPath();
        altCtx.arc(curX, curAltY, 3, 0, Math.PI * 2);
        altCtx.fill();
    }
}

requestAnimationFrame(frame);

})(); // end async init
</script>
</body>
</html>
